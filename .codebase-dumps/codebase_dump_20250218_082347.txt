🗂 DeepType Codebase Dump
📅 Generated on: Tue Feb 18 08:23:47 PST 2025
═══════════════════════════════════════════════════

📌 Core System Files
───────────────────────────────────────────────────

🟦 File: src/ai/services/typing-tutor.service.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Service: AI Typing Tutor                                                                       ║
 * ║ Description: Core AI service for generating lessons, analyzing performance, and giving feedback ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { AIAdapter } from '../adapters/base.adapter';
import { UserProfile, Lesson, TypingSession, Analysis, TutorFeedback, FeedbackRequest } from '../../types/typing';
import { ErrorAnalysisWorker } from '../../lib/typing/error-analysis.worker';
import { getConfig } from '../../config/ai.config';

interface IAITutorService {
  generateLesson(user: UserProfile): Promise<Lesson>;
  analyzePerformance(session: TypingSession): Promise<Analysis>;
  provideFeedback(input: FeedbackRequest): Promise<TutorFeedback>;
}

export class AITutorService implements IAITutorService {
  private readonly worker: ErrorAnalysisWorker;
  private readonly config = getConfig();

  constructor(private adapter: AIAdapter) {
    this.worker = new ErrorAnalysisWorker();
    this.initializeService();
  }

  private async initializeService(): Promise<void> {
    console.info('Initializing AI Tutor Service with config:', {
      model: this.config.model,
      temperature: this.config.temperature,
      maxTokens: this.config.maxTokens,
    });
  }

  async generateLesson(user: UserProfile): Promise<Lesson> {
    try {
      const prompt = this.buildLessonPrompt(user);
      const response = await this.adapter.generateContent(prompt);

      return this.parseLessonResponse(response, user.level);
    } catch (error) {
      console.error('Failed to generate lesson:', error);
      return this.getFallbackLesson(user.level);
    }
  }

  async analyzePerformance(session: TypingSession): Promise<Analysis> {
    try {
      // Offload heavy computation to web worker
      const analysis = await this.worker.analyze(session);

      // Enhance analysis with AI insights
      const aiInsights = await this.adapter.generateContent(
        this.buildAnalysisPrompt(session, analysis)
      );

      return {
        ...analysis,
        aiRecommendations: this.parseAIInsights(aiInsights),
      };
    } catch (error) {
      console.error('Failed to analyze performance:', error);
      return this.getFallbackAnalysis(session);
    }
  }

  async provideFeedback(input: FeedbackRequest): Promise<TutorFeedback> {
    try {
      const prompt = this.buildFeedbackPrompt(input);
      const response = await this.adapter.generateContent(prompt);

      return this.parseFeedbackResponse(response);
    } catch (error) {
      console.error('Failed to provide feedback:', error);
      return this.getFallbackFeedback(input);
    }
  }

  private buildLessonPrompt(user: UserProfile): string {
    return `Generate a typing lesson for:
Level: ${user.level}
Progress: ${user.accuracy}% accuracy, ${user.wpm} WPM
Weak keys: ${user.weakKeys.join(', ')}
Learning style: ${user.learningStyle}
Previous mistakes: ${JSON.stringify(user.recentMistakes)}
Focus areas: ${user.focusAreas.join(', ')}`;
  }

  private buildAnalysisPrompt(session: TypingSession, baseAnalysis: Analysis): string {
    return `Analyze typing performance:
Session data: ${JSON.stringify(session)}
Base analysis: ${JSON.stringify(baseAnalysis)}
Provide specific recommendations for improvement.`;
  }

  private buildFeedbackPrompt(input: FeedbackRequest): string {
    return `Provide typing feedback:
Current text: ${input.currentText}
Target text: ${input.targetText}
Recent mistakes: ${JSON.stringify(input.recentMistakes)}
User level: ${input.userLevel}
Learning style: ${input.learningStyle}`;
  }

  private parseLessonResponse(response: string, level: number): Lesson {
    try {
      return JSON.parse(response);
    } catch (error) {
      console.error('Failed to parse lesson response:', error);
      return this.getFallbackLesson(level);
    }
  }

  private parseAIInsights(insights: string): string[] {
    try {
      return JSON.parse(insights);
    } catch (error) {
      console.error('Failed to parse AI insights:', error);
      return ['Focus on accuracy and consistent speed'];
    }
  }

  private parseFeedbackResponse(response: string): TutorFeedback {
    try {
      return JSON.parse(response);
    } catch (error) {
      console.error('Failed to parse feedback response:', error);
      return {
        message: 'Keep practicing to improve your speed and accuracy.',
        corrections: [],
        suggestions: ['Take your time to type accurately'],
      };
    }
  }

  private getFallbackLesson(level: number): Lesson {
    const lessons = {
      1: 'The quick brown fox jumps over the lazy dog.',
      2: 'Pack my box with five dozen liquor jugs.',
      3: 'How vexingly quick daft zebras jump!',
      4: 'The five boxing wizards jump quickly.',
      5: 'Sphinx of black quartz, judge my vow.',
    };

    return {
      id: `fallback-${Date.now()}`,
      content: lessons[level as keyof typeof lessons] || lessons[1],
      level,
      focusKeys: [],
      estimatedDuration: 300,
    };
  }

  private getFallbackAnalysis(session: TypingSession): Analysis {
    return {
      wpm: session.wpm,
      accuracy: session.accuracy,
      errorPatterns: [],
      speedTrends: [],
      recommendedFocus: ['Practice for consistent speed and accuracy'],
      aiRecommendations: ['Continue practicing to build muscle memory'],
    };
  }

  private getFallbackFeedback(input: FeedbackRequest): TutorFeedback {
    return {
      message: 'Keep practicing to improve your typing skills.',
      corrections: input.recentMistakes.map(mistake => ({
        actual: mistake.actual,
        expected: mistake.expected,
        suggestion: 'Type carefully and accurately',
      })),
      suggestions: ['Focus on accuracy first, then speed will follow'],
    };
  }
}```


🟦 File: src/components/typing/accessible-keyboard.tsx
───────────────────────────────────────────────────
```tsx
```


🟦 File: src/hooks/useAI.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: AI Hook                                                                                ║
 * ║ Description: React hook for using AI capabilities in components                                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { useSupabase } from './useSupabase';
import { getAICore } from '@/lib/ai-utils';
import { TutorResponse, TypingAnalysis } from '@/lib/ai-core';
import { useToast } from '@/components/ui/use-toast';

interface UseAIOptions {
  onStreamUpdate?: (text: string) => void;
  enableStreaming?: boolean;
}

interface UseAIReturn {
  generateLesson: (level: number, mistakes: string[], style: string) => Promise<string>;
  getTutoring: (
    current: string,
    target: string,
    mistakes: Array<{ actual: string; expected: string }>,
    level: number
  ) => Promise<TutorResponse>;
  analyzePatterns: (
    mistakes: Array<{ actual: string; expected: string }>,
    speeds: number[]
  ) => Promise<TypingAnalysis>;
  isLoading: boolean;
  error: Error | null;
  clearError: () => void;
}

export function useAI(options: UseAIOptions = {}): UseAIReturn {
  const { supabase } = useSupabase();
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  // Initialize AI core with streaming if enabled
  const ai = getAICore(
    supabase,
    options.enableStreaming ? options.onStreamUpdate : undefined
  );

  // Cleanup function for aborting ongoing requests
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Error handling utility
  const handleError = useCallback((error: unknown) => {
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    console.error('AI Error:', error);
    setError(new Error(errorMessage));
    toast({
      title: 'AI Error',
      description: errorMessage,
      variant: 'destructive'
    });
    setIsLoading(false);
  }, [toast]);

  // Clear error state
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Generate lesson content
  const generateLesson = useCallback(async (
    level: number,
    mistakes: string[],
    style: string
  ): Promise<string> => {
    try {
      setIsLoading(true);
      setError(null);

      // Create new abort controller for this request
      abortControllerRef.current = new AbortController();

      const content = await ai.generateLessonContent(level, mistakes, style);

      console.info('Generated lesson content:', {
        contentLength: content.length,
        level,
        mistakeCount: mistakes.length,
        style
      });

      return content;
    } catch (error) {
      handleError(error);
      return 'Failed to generate lesson content. Please try again.';
    } finally {
      setIsLoading(false);
    }
  }, [ai, handleError]);

  // Get real-time tutoring feedback
  const getTutoring = useCallback(async (
    current: string,
    target: string,
    mistakes: Array<{ actual: string; expected: string }>,
    level: number
  ): Promise<TutorResponse> => {
    try {
      setIsLoading(true);
      setError(null);

      // Create new abort controller for this request
      abortControllerRef.current = new AbortController();

      const response = await ai.provideTutoring(current, target, mistakes, level);

      console.info('Generated tutoring response:', {
        hasFeedback: !!response.feedback,
        hasNextLesson: !!response.nextLesson,
        hintCount: response.adaptiveHints?.length
      });

      return response;
    } catch (error) {
      handleError(error);
      return {
        feedback: 'Failed to generate tutoring feedback. Please continue practicing.',
        confidenceScore: 0.5
      };
    } finally {
      setIsLoading(false);
    }
  }, [ai, handleError]);

  // Analyze typing patterns
  const analyzePatterns = useCallback(async (
    mistakes: Array<{ actual: string; expected: string }>,
    speeds: number[]
  ): Promise<TypingAnalysis> => {
    try {
      setIsLoading(true);
      setError(null);

      // Create new abort controller for this request
      abortControllerRef.current = new AbortController();

      const analysis = await ai.analyzeTypingPatterns(mistakes, speeds);

      console.info('Generated pattern analysis:', {
        patternCount: analysis.errorPatterns.length,
        speedDataPoints: analysis.speedTrends.length,
        focusAreas: analysis.recommendedFocus
      });

      return analysis;
    } catch (error) {
      handleError(error);
      return {
        errorPatterns: [],
        speedTrends: [],
        recommendedFocus: ['Focus on accuracy and consistent speed']
      };
    } finally {
      setIsLoading(false);
    }
  }, [ai, handleError]);

  return {
    generateLesson,
    getTutoring,
    analyzePatterns,
    isLoading,
    error,
    clearError
  };
}```


🟦 File: src/types/typing.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Types: Typing Core                                                                             ║
 * ║ Description: Type definitions for typing tutor core functionality                              ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

/**
 * Finger positions for touch typing
 */
export type FingerPosition =
  | 'left-pinky' | 'left-ring' | 'left-middle' | 'left-index'
  | 'right-index' | 'right-middle' | 'right-ring' | 'right-pinky';

/**
 * Metadata for each key on the keyboard
 */
export interface KeyMetadata {
  character: string;
  finger: FingerPosition;
  frequencyScore: number;
  soundProfile: string;
  hapticPattern: HapticPattern;
}

/**
 * User profile with typing preferences and history
 */
export interface UserProfile {
  id: string;
  level: number;
  accuracy: number;
  wpm: number;
  weakKeys: string[];
  learningStyle: 'visual' | 'auditory' | 'kinesthetic';
  recentMistakes: Array<{ actual: string; expected: string }>;
  focusAreas: string[];
  preferences: {
    soundEnabled: boolean;
    hapticEnabled: boolean;
    visualGuides: boolean;
    keyboardLayout: 'qwerty' | 'dvorak' | 'colemak';
  };
}

/**
 * A typing lesson with content and metadata
 */
export interface Lesson {
  id: string;
  content: string;
  level: number;
  focusKeys: string[];
  estimatedDuration: number;
  metadata?: {
    category?: string;
    tags?: string[];
    source?: string;
    difficulty?: 'beginner' | 'intermediate' | 'advanced';
  };
}

/**
 * A typing session with performance metrics
 */
export interface TypingSession {
  id: string;
  userId: string;
  startTime: Date;
  endTime: Date;
  wpm: number;
  accuracy: number;
  errors: Array<{
    actual: string;
    expected: string;
    timestamp: number;
    position: number;
  }>;
  keyPressTimings: Record<string, number[]>;
  pauseDurations: number[];
  completedText: string;
  targetText: string;
}

/**
 * Analysis of typing performance
 */
export interface Analysis {
  wpm: number;
  accuracy: number;
  errorPatterns: Array<{
    pattern: string;
    frequency: number;
    suggestion: string;
  }>;
  speedTrends: Array<{
    timestamp: string;
    wpm: number;
  }>;
  recommendedFocus: string[];
  aiRecommendations: string[];
}

/**
 * Request for AI tutor feedback
 */
export interface FeedbackRequest {
  currentText: string;
  targetText: string;
  recentMistakes: Array<{ actual: string; expected: string }>;
  userLevel: number;
  learningStyle: string;
  context?: {
    lessonType?: string;
    previousAttempts?: number;
    timeSpent?: number;
  };
}

/**
 * AI tutor feedback response
 */
export interface TutorFeedback {
  message: string;
  corrections: Array<{
    actual: string;
    expected: string;
    suggestion: string;
  }>;
  suggestions: string[];
  metadata?: {
    confidence: number;
    focusAreas?: string[];
    nextLessonRecommendation?: string;
  };
}

/**
 * Haptic feedback pattern
 */
export interface HapticPattern {
  intensity: number;
  duration: number;
  pattern: number[];
  description: string;
}

/**
 * Performance metrics for analytics
 */
export interface TypingMetrics {
  userId: string;
  sessionId: string;
  timestamp: number;
  metrics: {
    wpm: number;
    accuracy: number;
    errorRate: number;
    backspaceCount: number;
    pauseCount: number;
    totalTime: number;
    activeTime: number;
  };
  heatmap: Record<string, number>;
  progression: {
    levelProgress: number;
    achievementsUnlocked: string[];
    skillsImproved: string[];
  };
}

/**
 * Raw typing session data for analysis
 */
export interface TypingSessionData {
  keyPresses: Array<{
    key: string;
    timestamp: number;
    duration: number;
    pressure?: number;
  }>;
  errors: Array<{
    expected: string;
    actual: string;
    position: number;
    timestamp: number;
  }>;
  metrics: {
    wpm: number;
    accuracy: number;
    duration: number;
    pauseCount: number;
  };
  context: {
    lessonId: string;
    difficulty: string;
    targetText: string;
    completedText: string;
  };
}```


🟦 File: src/config/ai.config.ts
───────────────────────────────────────────────────
```ts
/*
 *  █████╗ ██╗     ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗
 * ██╔══██╗██║    ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝
 * ███████║██║    ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗
 * ██╔══██║██║    ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║
 * ██║  ██║██║    ╚██████╗╚██████╔╝██║ ╚████║██║     ██║╚██████╔╝
 * ╚═╝  ╚═╝╚═╝     ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝ ╚═════╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Config: AI Service Configuration                                                               ║
 * ║ Description: Configuration settings for AI-powered typing tutor                                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { AIAdapterConfig } from '../adapters/base.adapter';

/**
 * Default configuration for AI services
 */
export const DEFAULT_AI_CONFIG: AIAdapterConfig = {
  // API Configuration
  apiKey: process.env.OPENAI_API_KEY,
  endpoint: 'https://api.openai.com/v1/chat/completions',
  modelName: 'gpt-4-turbo-preview',
  temperature: 0.7,
  maxTokens: 1000,
  requestTimeout: 30000, // 30 seconds

  // Retry Configuration
  retryConfig: {
    maxRetries: 3,
    backoffFactor: 1.5,
    initialDelay: 1000, // 1 second
  },

  // Cache Configuration
  cacheConfig: {
    enabled: true,
    ttl: 3600, // 1 hour
    maxSize: 1000, // number of items
  },
};

/**
 * Lesson generation parameters
 */
export const LESSON_CONFIG = {
  minLength: 100, // characters
  maxLength: 500, // characters
  difficultyLevels: {
    beginner: {
      maxWordLength: 5,
      commonWordsOnly: true,
      includeNumbers: false,
      includeSpecialChars: false,
    },
    intermediate: {
      maxWordLength: 8,
      commonWordsOnly: false,
      includeNumbers: true,
      includeSpecialChars: false,
    },
    advanced: {
      maxWordLength: 12,
      commonWordsOnly: false,
      includeNumbers: true,
      includeSpecialChars: true,
    },
  },
  contentTypes: {
    code: {
      languages: ['typescript', 'javascript', 'python', 'java'],
      includeComments: true,
      maxLineLength: 80,
    },
    text: {
      categories: ['general', 'business', 'technical', 'creative'],
      formatOptions: ['sentences', 'paragraphs', 'dialogue'],
    },
  },
};

/**
 * Performance analysis thresholds
 */
export const ANALYSIS_CONFIG = {
  accuracy: {
    excellent: 98,
    good: 95,
    needsImprovement: 90,
  },
  wpm: {
    beginner: {
      target: 30,
      minimum: 20,
    },
    intermediate: {
      target: 50,
      minimum: 40,
    },
    advanced: {
      target: 80,
      minimum: 60,
    },
    professional: {
      target: 100,
      minimum: 80,
    },
  },
  errorPatterns: {
    significantThreshold: 3, // occurrences
    timeWindow: 300000, // 5 minutes
  },
};

/**
 * Feedback generation settings
 */
export const FEEDBACK_CONFIG = {
  realTime: {
    enabled: true,
    minInterval: 1000, // 1 second
    maxSuggestions: 3,
  },
  sessionEnd: {
    detailedAnalysis: true,
    includeVisualizations: true,
    recommendationCount: 5,
  },
  adaptiveThresholds: {
    enabled: true,
    adjustmentFactor: 0.1,
    minThreshold: 0.5,
    maxThreshold: 1.5,
  },
};

/**
 * AI model prompts and templates
 */
export const AI_PROMPTS = {
  lessonGeneration: {
    system: `You are an expert typing tutor, specialized in creating personalized typing lessons.
Focus on the user's skill level, learning style, and specific areas for improvement.`,

    template: `Create a typing lesson for a {level} user focusing on {focusAreas}.
The lesson should be {contentType} with {difficulty} difficulty.
Include specific exercises for {weaknesses}.`,
  },

  feedback: {
    system: `You are a supportive typing coach, providing constructive feedback to help users improve.
Balance encouragement with specific, actionable suggestions.`,

    template: `Based on the recent performance:
- Accuracy: {accuracy}%
- Speed: {wpm} WPM
- Error Patterns: {errorPatterns}

Provide personalized feedback and recommendations.`,
  },

  analysis: {
    system: `You are an analytical typing assessment tool, identifying patterns and trends in typing behavior.
Focus on data-driven insights and practical improvement strategies.`,

    template: `Analyze the following typing session data:
- Duration: {duration}
- Key Metrics: {metrics}
- Error Distribution: {errorDistribution}

Provide a detailed analysis with actionable insights.`,
  },
};

/**
 * Environment-specific configurations
 */
export const ENV_CONFIG = {
  development: {
    ...DEFAULT_AI_CONFIG,
    cacheConfig: {
      enabled: true,
      ttl: 300, // 5 minutes
      maxSize: 100,
    },
    logging: {
      level: 'debug',
      detailed: true,
    },
  },

  production: {
    ...DEFAULT_AI_CONFIG,
    temperature: 0.5, // More deterministic
    cacheConfig: {
      enabled: true,
      ttl: 3600, // 1 hour
      maxSize: 1000,
    },
    logging: {
      level: 'error',
      detailed: false,
    },
  },

  test: {
    ...DEFAULT_AI_CONFIG,
    apiKey: 'test-key',
    endpoint: 'http://localhost:3000/mock-ai',
    cacheConfig: {
      enabled: false,
    },
    logging: {
      level: 'debug',
      detailed: true,
    },
  },
};```


🟦 File: src/lib/typing/error-analysis.worker.ts
───────────────────────────────────────────────────
```ts
/*
 * ███████╗██████╗ ██████╗  ██████╗ ██████╗     ██╗    ██╗ ██████╗ ██████╗ ██╗  ██╗███████╗██████╗
 * ██╔════╝██╔══██╗██╔══██╗██╔═══██╗██╔══██╗    ██║    ██║██╔═══██╗██╔══██╗██║ ██╔╝██╔════╝██╔══██╗
 * █████╗  ██████╔╝██████╔╝██║   ██║██████╔╝    ██║ █╗ ██║██║   ██║██████╔╝█████╔╝ █████╗  ██████╔╝
 * ██╔══╝  ██╔══██╗██╔══██╗██║   ██║██╔══██╗    ██║███╗██║██║   ██║██╔══██╗██╔═██╗ ██╔══╝  ██╔══██╗
 * ███████╗██║  ██║██║  ██║╚██████╔╝██║  ██║    ╚███╔███╔╝╚██████╔╝██║  ██║██║  ██╗███████╗██║  ██║
 * ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝     ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Worker: Error Analysis                                                                         ║
 * ║ Description: Web worker for analyzing typing errors and patterns                              ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { TypingSessionData, Analysis } from '../../types/typing';

/**
 * Error pattern categories for classification
 */
const ERROR_PATTERNS = {
  TRANSPOSITION: 'transposition',
  SUBSTITUTION: 'substitution',
  INSERTION: 'insertion',
  OMISSION: 'omission',
  REPETITION: 'repetition',
  CAPITALIZATION: 'capitalization',
  TIMING: 'timing'
} as const;

/**
 * Analyzes typing errors to identify patterns and provide insights
 */
class ErrorAnalysisWorker {
  private sessionData: TypingSessionData;
  private analysis: Analysis;

  constructor() {
    this.initializeAnalysis();
    self.addEventListener('message', this.handleMessage.bind(this));
  }

  /**
   * Initialize analysis object with default values
   */
  private initializeAnalysis(): void {
    this.analysis = {
      wpm: 0,
      accuracy: 0,
      errorPatterns: [],
      speedTrends: [],
      recommendedFocus: [],
      aiRecommendations: []
    };
  }

  /**
   * Handle incoming messages from the main thread
   */
  private handleMessage(event: MessageEvent): void {
    console.log('Worker received message:', { type: event.data.type });

    switch (event.data.type) {
      case 'ANALYZE_SESSION':
        this.sessionData = event.data.payload;
        this.analyzeSession();
        break;
      default:
        console.error('Unknown message type:', event.data.type);
    }
  }

  /**
   * Main analysis pipeline for typing session data
   */
  private analyzeSession(): void {
    console.log('Starting session analysis...');

    try {
      this.calculateBaseMetrics();
      this.identifyErrorPatterns();
      this.analyzeSpeedTrends();
      this.generateRecommendations();

      self.postMessage({
        type: 'ANALYSIS_COMPLETE',
        payload: this.analysis
      });
    } catch (error) {
      console.error('Error during analysis:', error);
      self.postMessage({
        type: 'ANALYSIS_ERROR',
        error: error.message
      });
    }
  }

  /**
   * Calculate basic typing metrics (WPM, accuracy)
   */
  private calculateBaseMetrics(): void {
    console.log('Calculating base metrics...');

    const { metrics } = this.sessionData;
    const totalChars = this.sessionData.context.targetText.length;
    const errorCount = this.sessionData.errors.length;

    this.analysis.wpm = metrics.wpm;
    this.analysis.accuracy = ((totalChars - errorCount) / totalChars) * 100;
  }

  /**
   * Identify patterns in typing errors
   */
  private identifyErrorPatterns(): void {
    console.log('Identifying error patterns...');

    const patterns = new Map<string, number>();

    this.sessionData.errors.forEach(error => {
      const pattern = this.classifyError(error.expected, error.actual);
      patterns.set(pattern, (patterns.get(pattern) || 0) + 1);
    });

    this.analysis.errorPatterns = Array.from(patterns.entries())
      .map(([pattern, frequency]) => ({
        pattern,
        frequency,
        suggestion: this.getSuggestionForPattern(pattern)
      }))
      .sort((a, b) => b.frequency - a.frequency);
  }

  /**
   * Classify type of error based on expected and actual input
   */
  private classifyError(expected: string, actual: string): string {
    if (actual === expected.toLowerCase() || actual === expected.toUpperCase()) {
      return ERROR_PATTERNS.CAPITALIZATION;
    }

    if (actual.length > expected.length) {
      return ERROR_PATTERNS.INSERTION;
    }

    if (actual.length < expected.length) {
      return ERROR_PATTERNS.OMISSION;
    }

    if (actual === expected[0].repeat(expected.length)) {
      return ERROR_PATTERNS.REPETITION;
    }

    if (actual === expected.split('').reverse().join('')) {
      return ERROR_PATTERNS.TRANSPOSITION;
    }

    return ERROR_PATTERNS.SUBSTITUTION;
  }

  /**
   * Analyze typing speed trends over time
   */
  private analyzeSpeedTrends(): void {
    console.log('Analyzing speed trends...');

    const timeWindows = this.splitIntoTimeWindows(60000); // 1-minute windows

    this.analysis.speedTrends = timeWindows.map(window => ({
      timestamp: new Date(window.startTime).toISOString(),
      wpm: this.calculateWPMForWindow(window)
    }));
  }

  /**
   * Split session data into time windows for trend analysis
   */
  private splitIntoTimeWindows(windowSize: number): Array<{
    startTime: number;
    keyPresses: typeof this.sessionData.keyPresses;
  }> {
    const windows: Array<{
      startTime: number;
      keyPresses: typeof this.sessionData.keyPresses;
    }> = [];

    const { keyPresses } = this.sessionData;
    if (keyPresses.length === 0) return windows;

    const startTime = keyPresses[0].timestamp;
    const endTime = keyPresses[keyPresses.length - 1].timestamp;

    for (let time = startTime; time < endTime; time += windowSize) {
      windows.push({
        startTime: time,
        keyPresses: keyPresses.filter(
          press => press.timestamp >= time && press.timestamp < time + windowSize
        )
      });
    }

    return windows;
  }

  /**
   * Calculate WPM for a specific time window
   */
  private calculateWPMForWindow(window: {
    startTime: number;
    keyPresses: typeof this.sessionData.keyPresses;
  }): number {
    const chars = window.keyPresses.length;
    const minutes = 1; // Fixed 1-minute windows
    return Math.round((chars / 5) / minutes);
  }

  /**
   * Generate personalized recommendations based on analysis
   */
  private generateRecommendations(): void {
    console.log('Generating recommendations...');

    const recommendations: string[] = [];
    const focusAreas: string[] = [];

    // Analyze error patterns
    if (this.analysis.errorPatterns.length > 0) {
      const mostCommonError = this.analysis.errorPatterns[0];
      recommendations.push(
        `Focus on reducing ${mostCommonError.pattern} errors by ${mostCommonError.suggestion}`
      );
      focusAreas.push(mostCommonError.pattern);
    }

    // Analyze speed consistency
    const speedVariance = this.calculateSpeedVariance();
    if (speedVariance > 10) {
      recommendations.push(
        'Work on maintaining consistent typing speed throughout practice sessions'
      );
      focusAreas.push('speed_consistency');
    }

    // Check accuracy threshold
    if (this.analysis.accuracy < 95) {
      recommendations.push(
        'Prioritize accuracy over speed - slow down and focus on correct finger placement'
      );
      focusAreas.push('accuracy');
    }

    this.analysis.aiRecommendations = recommendations;
    this.analysis.recommendedFocus = focusAreas;
  }

  /**
   * Calculate variance in typing speed
   */
  private calculateSpeedVariance(): number {
    const speeds = this.analysis.speedTrends.map(trend => trend.wpm);
    const mean = speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;

    const squaredDiffs = speeds.map(speed => Math.pow(speed - mean, 2));
    const variance = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / speeds.length;

    return Math.sqrt(variance);
  }

  /**
   * Get improvement suggestion for specific error pattern
   */
  private getSuggestionForPattern(pattern: string): string {
    const suggestions: Record<string, string> = {
      [ERROR_PATTERNS.TRANSPOSITION]: 'practice slower, deliberate key strikes',
      [ERROR_PATTERNS.SUBSTITUTION]: 'focus on finger placement and key mapping',
      [ERROR_PATTERNS.INSERTION]: 'work on key release timing',
      [ERROR_PATTERNS.OMISSION]: 'improve finger strength and key activation',
      [ERROR_PATTERNS.REPETITION]: 'practice key release timing',
      [ERROR_PATTERNS.CAPITALIZATION]: 'focus on shift key coordination',
      [ERROR_PATTERNS.TIMING]: 'maintain steady rhythm while typing'
    };

    return suggestions[pattern] || 'focus on overall accuracy';
  }
}

// Initialize worker
new ErrorAnalysisWorker();

// Export for type checking
export type { ErrorAnalysisWorker };```


💾 File: supabase/migrations/20240218_user_profiles.sql
───────────────────────────────────────────────────
```sql
-- Create profiles table
CREATE TABLE IF NOT EXISTS profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE,
  username TEXT UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  level INTEGER DEFAULT 1,
  total_lessons_completed INTEGER DEFAULT 0,
  total_practice_time INTEGER DEFAULT 0,
  average_wpm INTEGER DEFAULT 0,
  average_accuracy INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  PRIMARY KEY (id)
);

-- Create typing_progress table
CREATE TABLE IF NOT EXISTS typing_progress (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE,
  wpm INTEGER NOT NULL,
  accuracy INTEGER NOT NULL,
  mistakes JSONB,
  level INTEGER NOT NULL,
  lesson_text TEXT,
  completed_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create achievements table
CREATE TABLE IF NOT EXISTS achievements (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  icon TEXT,
  criteria JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create user_achievements table
CREATE TABLE IF NOT EXISTS user_achievements (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE,
  achievement_id UUID REFERENCES achievements ON DELETE CASCADE,
  unlocked_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  UNIQUE(user_id, achievement_id)
);

-- Create typing_analysis table
CREATE TABLE IF NOT EXISTS typing_analysis (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE,
  error_patterns JSONB,
  speed_trends JSONB,
  recommended_focus TEXT[],
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create RLS policies
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE typing_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE typing_analysis ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Public profiles are viewable by everyone"
  ON profiles FOR SELECT
  USING (true);

CREATE POLICY "Users can insert their own profile"
  ON profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
  ON profiles FOR UPDATE
  USING (auth.uid() = id);

-- Typing progress policies
CREATE POLICY "Users can view their own typing progress"
  ON typing_progress FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own typing progress"
  ON typing_progress FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Achievements policies
CREATE POLICY "Achievements are viewable by everyone"
  ON achievements FOR SELECT
  USING (true);

-- User achievements policies
CREATE POLICY "Users can view their own achievements"
  ON user_achievements FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can unlock achievements"
  ON user_achievements FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Typing analysis policies
CREATE POLICY "Users can view their own typing analysis"
  ON typing_analysis FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own typing analysis"
  ON typing_analysis FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Create functions
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, avatar_url)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username',
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE handle_new_user();```


💾 File: supabase/migrations/20240219_leaderboard_functions.sql
───────────────────────────────────────────────────
```sql
-- Create a function to get leaderboard data
CREATE OR REPLACE FUNCTION get_leaderboard(
  p_limit integer DEFAULT 100,
  p_time_period text DEFAULT 'all',
  p_sort_by text DEFAULT 'wpm'
)
RETURNS TABLE (
  id uuid,
  username text,
  full_name text,
  avatar_url text,
  average_wpm integer,
  average_accuracy integer,
  total_lessons_completed integer,
  level integer,
  achievements_count bigint,
  rank bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_start_date timestamp;
BEGIN
  -- Set time period filter
  CASE p_time_period
    WHEN 'today' THEN
      v_start_date := current_date;
    WHEN 'week' THEN
      v_start_date := date_trunc('week', current_date);
    WHEN 'month' THEN
      v_start_date := date_trunc('month', current_date);
    ELSE
      v_start_date := '1970-01-01'::timestamp;
  END CASE;

  -- Return leaderboard data
  RETURN QUERY
  WITH achievement_counts AS (
    SELECT
      user_id,
      COUNT(*) as achievements_count
    FROM user_achievements
    GROUP BY user_id
  ),
  ranked_users AS (
    SELECT
      p.id,
      p.username,
      p.full_name,
      p.avatar_url,
      p.average_wpm,
      p.average_accuracy,
      p.total_lessons_completed,
      p.level,
      COALESCE(ac.achievements_count, 0) as achievements_count,
      ROW_NUMBER() OVER (
        ORDER BY
          CASE p_sort_by
            WHEN 'wpm' THEN p.average_wpm
            WHEN 'accuracy' THEN p.average_accuracy
            WHEN 'lessons' THEN p.total_lessons_completed
            WHEN 'achievements' THEN COALESCE(ac.achievements_count, 0)
          END DESC
      ) as rank
    FROM profiles p
    LEFT JOIN achievement_counts ac ON p.id = ac.user_id
    WHERE
      CASE p_time_period
        WHEN 'all' THEN true
        ELSE p.last_lesson_date >= v_start_date
      END
  )
  SELECT *
  FROM ranked_users
  LIMIT p_limit;
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION get_leaderboard TO authenticated;```

📂 Component Files
───────────────────────────────────────────────────

🟦 File: src/lib/__tests__/ai-core.test.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: AI Core Tests                                                                          ║
 * ║ Description: Test suite for AI core functionality                                              ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { AICore, AIConfig } from '../ai-core'
import { createClient } from '@supabase/supabase-js'
import { getConfig } from '../config'

// Mock external dependencies
vi.mock('@supabase/supabase-js', () => ({
  createClient: vi.fn(() => ({
    from: vi.fn(() => ({
      insert: vi.fn().mockResolvedValue({ data: null, error: null }),
      select: vi.fn().mockResolvedValue({ data: [], error: null })
    }))
  }))
}))

vi.mock('../config', () => ({
  getConfig: vi.fn(() => ({
    openaiApiKey: 'test-openai-key',
    googleAiApiKey: 'test-gemini-key',
    aiModel: 'gemini-pro',
    aiTemperature: 0.7,
    aiMaxTokens: 2048,
    supabaseUrl: 'https://test.supabase.co',
    supabaseAnonKey: 'test-anon-key',
    enableRealTimeAnalysis: true,
    enableVoiceCommands: true,
    enableHapticFeedback: true,
    enablePerformanceTracking: true,
    enableErrorTracking: true,
    analyticsSampleRate: 100
  }))
}))

describe('AICore', () => {
  let ai: AICore
  let supabase: ReturnType<typeof createClient>
  let config: AIConfig
  let streamCallback: (text: string) => void

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks()

    // Initialize test dependencies
    streamCallback = vi.fn()
    supabase = createClient('https://test.supabase.co', 'test-anon-key')
    config = {
      model: 'gemini-pro',
      temperature: 0.7,
      maxTokens: 2048,
      streamCallback
    }

    // Initialize AI core
    ai = new AICore(supabase, config)
  })

  afterEach(() => {
    vi.resetAllMocks()
  })

  describe('generateLessonContent', () => {
    it('should generate lesson content with Gemini', async () => {
      const mockContent = 'Practice typing: The quick brown fox jumps over the lazy dog'
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockResolvedValue({
          response: { text: () => mockContent }
        })
      })

      const content = await ai.generateLessonContent(1, [], 'standard')
      expect(content).toBe(mockContent)
    })

    it('should handle streaming responses', async () => {
      const mockChunks = ['Practice ', 'typing: ', 'Hello ', 'World']
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContentStream: vi.fn().mockResolvedValue({
          stream: {
            async *[Symbol.asyncIterator]() {
              for (const chunk of mockChunks) {
                yield { text: () => chunk }
              }
            }
          }
        })
      })

      const content = await ai.generateLessonContent(1, [], 'standard')
      expect(content).toBe(mockChunks.join(''))
      expect(streamCallback).toHaveBeenCalledTimes(mockChunks.length)
    })

    it('should fall back to basic content on error', async () => {
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockRejectedValue(new Error('API Error'))
      })

      const content = await ai.generateLessonContent(1, [], 'standard')
      expect(content).toContain('Practice typing home row keys')
    })
  })

  describe('provideTutoring', () => {
    const mockResponse = {
      feedback: 'Good progress!',
      nextLesson: 'Try capital letters next',
      adaptiveHints: ['Focus on finger placement'],
      confidenceScore: 0.8
    }

    it('should provide tutoring feedback', async () => {
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(mockResponse) }
        })
      })

      const response = await ai.provideTutoring('hello', 'hello world', [], 1)
      expect(response).toEqual(mockResponse)
    })

    it('should handle streaming tutoring responses', async () => {
      const mockChunks = [
        '{"feedback": "Good',
        ' progress!",',
        '"confidenceScore": 0.8}'
      ]
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContentStream: vi.fn().mockResolvedValue({
          stream: {
            async *[Symbol.asyncIterator]() {
              for (const chunk of mockChunks) {
                yield { text: () => chunk }
              }
            }
          }
        })
      })

      const response = await ai.provideTutoring('hello', 'hello world', [], 1)
      expect(response).toHaveProperty('feedback', 'Good progress!')
      expect(response).toHaveProperty('confidenceScore', 0.8)
      expect(streamCallback).toHaveBeenCalledTimes(mockChunks.length)
    })

    it('should handle errors gracefully', async () => {
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockRejectedValue(new Error('API Error'))
      })

      const response = await ai.provideTutoring('hello', 'hello world', [], 1)
      expect(response).toHaveProperty('feedback')
      expect(response.confidenceScore).toBe(0.5)
    })
  })

  describe('analyzeTypingPatterns', () => {
    const mockAnalysis = {
      errorPatterns: [
        {
          pattern: 'th -> ht',
          frequency: 3,
          suggestion: 'Practice "th" digraph'
        }
      ],
      speedTrends: [
        {
          timestamp: '2024-01-01T00:00:00Z',
          wpm: 45
        }
      ],
      recommendedFocus: ['Accuracy', 'Speed']
    }

    it('should analyze typing patterns', async () => {
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(mockAnalysis) }
        })
      })

      const analysis = await ai.analyzeTypingPatterns([], [45])
      expect(analysis).toEqual(mockAnalysis)
    })

    it('should store analysis in Supabase when tracking is enabled', async () => {
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockResolvedValue({
          response: { text: () => JSON.stringify(mockAnalysis) }
        })
      })

      await ai.analyzeTypingPatterns([], [45])
      expect(supabase.from).toHaveBeenCalledWith('typing_analysis')
      expect(supabase.from('typing_analysis').insert).toHaveBeenCalled()
    })

    it('should handle analysis errors gracefully', async () => {
      vi.spyOn(ai as any, 'geminiModel').mockImplementation({
        generateContent: vi.fn().mockRejectedValue(new Error('API Error'))
      })

      const analysis = await ai.analyzeTypingPatterns([], [45])
      expect(analysis.errorPatterns).toHaveLength(0)
      expect(analysis.recommendedFocus).toHaveLength(1)
    })
  })
})```


🟦 File: src/components/ui/input.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Input                                                                               ║
 * ║ Description: Reusable input component with consistent styling and accessibility                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```


🟦 File: src/components/layout/Navigation.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Navigation                                                                          ║
 * ║ Description: Main navigation bar with user menu and page links                                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import React from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useSupabase } from '@/hooks/useSupabase';
import { useQuery } from '@tanstack/react-query';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { useToast } from '@/components/ui/use-toast';

const Navigation: React.FC = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { supabase } = useSupabase();
  const { toast } = useToast();

  // Fetch user profile
  const { data: profile } = useQuery({
    queryKey: ['profile'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;

      const { data, error } = await supabase
        .from('profiles')
        .select('username, avatar_url, full_name')
        .eq('id', user.id)
        .single();

      if (error) throw error;
      return data;
    },
  });

  const handleSignOut = async () => {
    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;

      toast({
        title: 'Signed out successfully',
        description: 'See you next time!',
      });

      navigate('/auth');
    } catch (error) {
      console.error('Error signing out:', error);
      toast({
        title: 'Error',
        description: 'Failed to sign out. Please try again.',
        variant: 'destructive',
      });
    }
  };

  return (
    <nav className="border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-14 items-center">
        <div className="mr-4 hidden md:flex">
          <Link to="/" className="mr-6 flex items-center space-x-2">
            <span className="hidden font-bold sm:inline-block">
              DeepType
            </span>
          </Link>
          <div className="flex items-center space-x-6 text-sm font-medium">
            <Link
              to="/"
              className={location.pathname === '/' ? 'text-foreground' : 'text-muted-foreground'}
            >
              Practice
            </Link>
            <Link
              to="/profile"
              className={location.pathname === '/profile' ? 'text-foreground' : 'text-muted-foreground'}
            >
              Profile
            </Link>
            <Link
              to="/leaderboard"
              className={location.pathname === '/leaderboard' ? 'text-foreground' : 'text-muted-foreground'}
            >
              Leaderboard
            </Link>
          </div>
        </div>

        <div className="flex flex-1 items-center justify-between space-x-2 md:justify-end">
          <div className="w-full flex-1 md:w-auto md:flex-none">
            {/* Add search or other controls here */}
          </div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                className="relative h-8 w-8 rounded-full"
              >
                <Avatar className="h-8 w-8">
                  <AvatarImage src={profile?.avatar_url || undefined} />
                  <AvatarFallback>
                    {profile?.username?.slice(0, 2).toUpperCase() || 'U'}
                  </AvatarFallback>
                </Avatar>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>
                {profile?.full_name || profile?.username || 'User'}
              </DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem asChild>
                <Link to="/profile">Profile</Link>
              </DropdownMenuItem>
              <DropdownMenuItem
                className="text-red-600 focus:text-red-600"
                onClick={handleSignOut}
              >
                Sign Out
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </nav>
  );
};

export default Navigation;```


🟦 File: src/components/auth/ProtectedRoute.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: ProtectedRoute                                                                      ║
 * ║ Description: Route wrapper that checks for authentication before rendering protected content   ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import React, { useEffect, useState } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useSupabase } from '@/hooks/useSupabase';
import LoadingState from '@/components/LoadingState';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const { supabase } = useSupabase();
  const location = useLocation();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        setIsAuthenticated(!!session);
      } catch (error) {
        console.error('Auth check failed:', error);
        setIsAuthenticated(false);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setIsAuthenticated(!!session);
      setIsLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [supabase.auth]);

  if (isLoading) {
    return (
      <LoadingState
        fullScreen
        message="Checking authentication..."
      />
    );
  }

  if (!isAuthenticated) {
    // Redirect to login page with return path
    return <Navigate to="/auth" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;```


🟦 File: src/components/auth/AuthForm.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: AuthForm                                                                            ║
 * ║ Description: Authentication form with login, signup, and password reset functionality          ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import React, { useState } from 'react';
import { useSupabase } from '@/hooks/useSupabase';
import { useToast } from '@/components/ui/use-toast';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Spinner } from '@/components/ui/spinner';

type AuthMode = 'login' | 'signup' | 'reset';

const AuthForm: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [mode, setMode] = useState<AuthMode>('login');
  const [isLoading, setIsLoading] = useState(false);

  const { supabase } = useSupabase();
  const { toast } = useToast();

  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      if (mode === 'signup') {
        if (password !== confirmPassword) {
          throw new Error('Passwords do not match');
        }

        const { error } = await supabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/auth/callback`,
          },
        });

        if (error) throw error;

        toast({
          title: 'Check your email',
          description: 'We sent you a confirmation link to complete your signup.',
        });
      } else if (mode === 'login') {
        const { error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) throw error;

        toast({
          title: 'Welcome back!',
          description: 'Successfully logged in.',
        });
      } else if (mode === 'reset') {
        const { error } = await supabase.auth.resetPasswordForEmail(email, {
          redirectTo: `${window.location.origin}/auth/reset-password`,
        });

        if (error) throw error;

        toast({
          title: 'Check your email',
          description: 'We sent you a password reset link.',
        });
      }
    } catch (error) {
      console.error('Authentication error:', error);
      toast({
        title: 'Error',
        description: error instanceof Error ? error.message : 'An error occurred',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>Welcome to DeepType</CardTitle>
        <CardDescription>
          {mode === 'login'
            ? 'Sign in to continue your typing journey'
            : mode === 'signup'
            ? 'Create an account to start learning'
            : 'Reset your password'}
        </CardDescription>
      </CardHeader>

      <CardContent>
        <Tabs value={mode} onValueChange={(value) => setMode(value as AuthMode)}>
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="login">Login</TabsTrigger>
            <TabsTrigger value="signup">Sign Up</TabsTrigger>
            <TabsTrigger value="reset">Reset</TabsTrigger>
          </TabsList>

          <form onSubmit={handleAuth} className="space-y-4 mt-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="you@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>

            {mode !== 'reset' && (
              <div className="space-y-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  required
                />
              </div>
            )}

            {mode === 'signup' && (
              <div className="space-y-2">
                <Label htmlFor="confirmPassword">Confirm Password</Label>
                <Input
                  id="confirmPassword"
                  type="password"
                  value={confirmPassword}
                  onChange={(e) => setConfirmPassword(e.target.value)}
                  required
                />
              </div>
            )}

            <Button
              type="submit"
              className="w-full"
              disabled={isLoading}
            >
              {isLoading ? (
                <Spinner size="sm" className="mr-2" />
              ) : mode === 'login' ? (
                'Sign In'
              ) : mode === 'signup' ? (
                'Create Account'
              ) : (
                'Send Reset Link'
              )}
            </Button>
          </form>
        </Tabs>
      </CardContent>

      <CardFooter className="flex flex-col space-y-2">
        <div className="text-sm text-muted-foreground text-center">
          {mode === 'login' ? (
            <>
              Don't have an account?{' '}
              <Button
                variant="link"
                className="p-0 h-auto"
                onClick={() => setMode('signup')}
              >
                Sign up
              </Button>
            </>
          ) : mode === 'signup' ? (
            <>
              Already have an account?{' '}
              <Button
                variant="link"
                className="p-0 h-auto"
                onClick={() => setMode('login')}
              >
                Sign in
              </Button>
            </>
          ) : (
            <Button
              variant="link"
              className="p-0 h-auto"
              onClick={() => setMode('login')}
            >
              Back to login
            </Button>
          )}
        </div>
      </CardFooter>
    </Card>
  );
};

export default AuthForm;```


🟦 File: src/components/PerformanceChart.tsx
───────────────────────────────────────────────────
```tsx

import React from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

interface PerformanceData {
  date: string;
  wpm: number;
  accuracy: number;
}

interface PerformanceChartProps {
  data: PerformanceData[];
}

const PerformanceChart: React.FC<PerformanceChartProps> = ({ data }) => {
  return (
    <div className="w-full h-[300px] bg-black/30 p-4 rounded-xl backdrop-blur-sm border border-border/50">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={data} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
          <CartesianGrid strokeDasharray="3 3" stroke="#333" />
          <XAxis 
            dataKey="date" 
            stroke="#666"
            tickFormatter={(value) => new Date(value).toLocaleDateString()}
          />
          <YAxis yAxisId="left" stroke="#9b87f5" />
          <YAxis yAxisId="right" orientation="right" stroke="#0EA5E9" />
          <Tooltip 
            contentStyle={{ 
              backgroundColor: 'rgba(0,0,0,0.8)', 
              border: '1px solid #333',
              borderRadius: '8px'
            }}
          />
          <Legend />
          <Line
            yAxisId="left"
            type="monotone"
            dataKey="wpm"
            name="WPM"
            stroke="#9b87f5"
            activeDot={{ r: 8 }}
          />
          <Line
            yAxisId="right"
            type="monotone"
            dataKey="accuracy"
            name="Accuracy %"
            stroke="#0EA5E9"
            activeDot={{ r: 8 }}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
};

export default PerformanceChart;
```


🟦 File: src/hooks/useSupabase.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Supabase Hook                                                                          ║
 * ║ Description: React hook for accessing Supabase client and authentication                       ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { createClient } from '@supabase/supabase-js';
import { useEffect, useState } from 'react';
import { getConfig } from '@/lib/config';

// Initialize Supabase client
const config = getConfig();
const supabase = createClient(
  config.supabaseUrl,
  config.supabaseAnonKey
);

interface UseSupabaseReturn {
  supabase: typeof supabase;
  isInitialized: boolean;
}

export function useSupabase(): UseSupabaseReturn {
  const [isInitialized, setIsInitialized] = useState(false);

  useEffect(() => {
    // Verify connection and set initialized state
    const checkConnection = async () => {
      try {
        const { data, error } = await supabase.from('health_check').select('*').limit(1);
        if (error) throw error;
        console.info('Supabase connection verified');
        setIsInitialized(true);
      } catch (error) {
        console.error('Failed to connect to Supabase:', error);
        setIsInitialized(false);
      }
    };

    checkConnection();
  }, []);

  return {
    supabase,
    isInitialized
  };
}

// Export singleton instance for non-React usage
export { supabase };```


🟦 File: src/hooks/useLeaderboard.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Leaderboard Hook                                                                       ║
 * ║ Description: React hook for managing leaderboard data with filtering and sorting               ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useSupabase } from './useSupabase';
import { useToast } from '@/components/ui/use-toast';

export type TimePeriod = 'all' | 'today' | 'week' | 'month';
export type SortBy = 'wpm' | 'accuracy' | 'lessons' | 'achievements';

export interface LeaderboardEntry {
  id: string;
  username: string;
  full_name: string | null;
  avatar_url: string | null;
  average_wpm: number;
  average_accuracy: number;
  total_lessons_completed: number;
  level: number;
  achievements_count: number;
  rank: number;
}

interface UseLeaderboardOptions {
  limit?: number;
  timePeriod?: TimePeriod;
  sortBy?: SortBy;
  refetchInterval?: number;
  onError?: (error: Error) => void;
}

interface UseLeaderboardReturn {
  leaderboard: LeaderboardEntry[];
  isLoading: boolean;
  error: Error | null;
  currentUserRank: number | null;
  refetch: () => Promise<void>;
  invalidate: () => Promise<void>;
}

export function useLeaderboard({
  limit = 100,
  timePeriod = 'all',
  sortBy = 'wpm',
  refetchInterval = 30000,
  onError,
}: UseLeaderboardOptions = {}): UseLeaderboardReturn {
  const { supabase } = useSupabase();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Get current user for rank highlighting
  const { data: currentUser } = useQuery({
    queryKey: ['user'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      return user;
    },
  });

  // Fetch leaderboard data
  const { data: leaderboard = [], isLoading, error } = useQuery({
    queryKey: ['leaderboard', timePeriod, sortBy, limit],
    queryFn: async () => {
      try {
        const { data, error } = await supabase
          .rpc('get_leaderboard', {
            p_limit: limit,
            p_time_period: timePeriod,
            p_sort_by: sortBy
          });

        if (error) throw error;
        return data as LeaderboardEntry[];
      } catch (error) {
        console.error('Error fetching leaderboard:', error);
        const errorMessage = error instanceof Error ? error.message : 'Failed to fetch leaderboard';
        toast({
          title: 'Error',
          description: errorMessage,
          variant: 'destructive',
        });
        onError?.(error as Error);
        throw error;
      }
    },
    refetchInterval,
  });

  // Find current user's rank
  const currentUserRank = currentUser
    ? leaderboard.find(entry => entry.id === currentUser.id)?.rank ?? null
    : null;

  // Function to manually refetch data
  const refetch = async () => {
    try {
      await queryClient.invalidateQueries({
        queryKey: ['leaderboard', timePeriod, sortBy, limit],
      });
    } catch (error) {
      console.error('Error refetching leaderboard:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to refetch leaderboard';
      toast({
        title: 'Error',
        description: errorMessage,
        variant: 'destructive',
      });
      onError?.(error as Error);
    }
  };

  // Function to invalidate cache
  const invalidate = async () => {
    await queryClient.invalidateQueries({
      queryKey: ['leaderboard'],
    });
  };

  return {
    leaderboard,
    isLoading,
    error: error as Error | null,
    currentUserRank,
    refetch,
    invalidate,
  };
}

// Export a function to format rank display
export function formatRank(rank: number): string {
  const suffixes = ['th', 'st', 'nd', 'rd'];
  const v = rank % 100;
  return rank + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);
}

// Export a function to get rank color
export function getRankColor(rank: number): string {
  switch (rank) {
    case 1:
      return 'text-yellow-500';
    case 2:
      return 'text-slate-400';
    case 3:
      return 'text-amber-600';
    default:
      return 'text-muted-foreground';
  }
}

// Export a function to get rank icon
export function getRankIcon(rank: number): string {
  switch (rank) {
    case 1:
      return '🏆';
    case 2:
      return '🥈';
    case 3:
      return '🥉';
    default:
      return `#${rank}`;
  }
}```


🟦 File: src/hooks/useAchievements.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Achievement Hook                                                                       ║
 * ║ Description: React hook for managing achievements and progress                                 ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { useEffect, useMemo } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useSupabase } from './useSupabase';
import { useToast } from '@/components/ui/use-toast';
import { createAchievementManager, type AchievementProgress } from '@/lib/achievements';

interface UseAchievementsReturn {
  achievements: AchievementProgress[];
  isLoading: boolean;
  error: Error | null;
  checkAchievements: (stats: {
    wpm: number;
    accuracy: number;
    lessons: number;
    streak: number;
    practiceTime: number;
    isPerfectScore: boolean;
  }) => Promise<void>;
}

export function useAchievements(): UseAchievementsReturn {
  const { supabase } = useSupabase();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Get current user
  const { data: user } = useQuery({
    queryKey: ['user'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('No user found');
      return user;
    },
  });

  // Create achievement manager instance
  const achievementManager = useMemo(() => {
    if (!user) return null;
    return createAchievementManager(supabase, user.id, toast);
  }, [user, supabase, toast]);

  // Fetch achievements progress
  const { data: achievements, isLoading, error } = useQuery({
    queryKey: ['achievements', user?.id],
    queryFn: async () => {
      if (!achievementManager) throw new Error('Achievement manager not initialized');
      return achievementManager.getProgress();
    },
    enabled: !!achievementManager,
  });

  // Function to check achievements
  const checkAchievements = async (stats: {
    wpm: number;
    accuracy: number;
    lessons: number;
    streak: number;
    practiceTime: number;
    isPerfectScore: boolean;
  }) => {
    if (!achievementManager) {
      console.error('Achievement manager not initialized');
      return;
    }

    await achievementManager.checkAndUnlockAchievements(stats);
    // Invalidate achievements query to refresh the data
    queryClient.invalidateQueries({ queryKey: ['achievements', user?.id] });
  };

  // Log achievement system initialization
  useEffect(() => {
    if (achievementManager) {
      console.info('Achievement system initialized for user:', user?.id);
    }
  }, [achievementManager, user?.id]);

  return {
    achievements: achievements || [],
    isLoading,
    error: error as Error | null,
    checkAchievements,
  };
}```


🟦 File: src/hooks/use-screen-reader.ts
───────────────────────────────────────────────────
```ts
/*
 * ███████╗ ██████╗██████╗ ███████╗███████╗███╗   ██╗
 * ██╔════╝██╔════╝██╔══██╗██╔════╝██╔════╝████╗  ██║
 * ███████╗██║     ██████╔╝█████╗  █████╗  ██╔██╗ ██║
 * ╚════██║██║     ██╔══██╗██╔══╝  ██╔══╝  ██║╚██╗██║
 * ███████║╚██████╗██║  ██║███████╗███████╗██║ ╚████║
 * ╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Hook: Screen Reader                                                                            ║
 * ║ Description: Custom hook for managing screen reader announcements                              ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { useCallback, useEffect, useRef, useState } from 'react';

interface ScreenReaderConfig {
  enabled: boolean;
  volume: number;
  rate: number;
  pitch: number;
  voice?: string;
  language?: string;
}

interface AnnouncementOptions {
  priority?: 'high' | 'medium' | 'low';
  interrupt?: boolean;
  delay?: number;
}

/**
 * Default configuration
 */
const DEFAULT_CONFIG: ScreenReaderConfig = {
  enabled: true,
  volume: 1.0,
  rate: 1.0,
  pitch: 1.0,
  language: 'en-US'
};

/**
 * Custom hook for managing screen reader announcements
 */
export function useScreenReader(config: Partial<ScreenReaderConfig> = {}) {
  // Merge default config with provided config
  const screenReaderConfig = { ...DEFAULT_CONFIG, ...config };

  // State for tracking support and status
  const [isSupported, setIsSupported] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const [selectedVoice, setSelectedVoice] = useState<SpeechSynthesisVoice | null>(null);

  // Refs for managing announcements
  const synthesis = useRef<SpeechSynthesis | null>(null);
  const announcementQueue = useRef<Array<{
    text: string;
    options: AnnouncementOptions;
  }>>([]);
  const isProcessingQueue = useRef(false);

  /**
   * Initialize screen reader
   */
  useEffect(() => {
    checkScreenReaderSupport().then(supported => {
      setIsSupported(supported);
      if (supported) {
        synthesis.current = window.speechSynthesis;
        initializeVoice();
      }
      setIsReady(true);
    });

    return () => {
      if (synthesis.current) {
        synthesis.current.cancel();
      }
    };
  }, []);

  /**
   * Check if screen reader is supported
   */
  const checkScreenReaderSupport = async (): Promise<boolean> => {
    return 'speechSynthesis' in window;
  };

  /**
   * Initialize voice selection
   */
  const initializeVoice = () => {
    if (!synthesis.current) return;

    // Wait for voices to be loaded
    const handleVoicesChanged = () => {
      const voices = synthesis.current?.getVoices() || [];
      console.log('Available voices:', voices.length);

      // Select voice based on config
      const voice = voices.find(v =>
        v.name === screenReaderConfig.voice ||
        v.lang === screenReaderConfig.language
      ) || voices.find(v => v.default) || voices[0];

      if (voice) {
        setSelectedVoice(voice);
        console.log('Selected voice:', voice.name);
      } else {
        console.warn('No suitable voice found');
      }
    };

    synthesis.current.addEventListener('voiceschanged', handleVoicesChanged);
    handleVoicesChanged(); // Initial check
  };

  /**
   * Process the announcement queue
   */
  const processQueue = useCallback(async () => {
    if (isProcessingQueue.current || !synthesis.current || !selectedVoice) return;

    isProcessingQueue.current = true;

    while (announcementQueue.current.length > 0) {
      const announcement = announcementQueue.current[0];

      try {
        await speak(announcement.text, announcement.options);
        announcementQueue.current.shift();
      } catch (error) {
        console.error('Error processing announcement:', error);
        break;
      }
    }

    isProcessingQueue.current = false;
  }, [selectedVoice]);

  /**
   * Speak text using screen reader
   */
  const speak = (text: string, options: AnnouncementOptions = {}): Promise<void> => {
    return new Promise((resolve, reject) => {
      if (!synthesis.current || !selectedVoice) {
        reject(new Error('Screen reader not initialized'));
        return;
      }

      // Create utterance
      const utterance = new SpeechSynthesisUtterance(text);

      // Configure utterance
      utterance.voice = selectedVoice;
      utterance.volume = screenReaderConfig.volume;
      utterance.rate = screenReaderConfig.rate;
      utterance.pitch = screenReaderConfig.pitch;

      // Handle events
      utterance.onend = () => {
        console.log('Finished speaking:', text);
        resolve();
      };

      utterance.onerror = (event) => {
        console.error('Speech synthesis error:', event);
        reject(event);
      };

      // Speak
      if (options.interrupt) {
        synthesis.current.cancel();
      }

      if (options.delay) {
        setTimeout(() => {
          synthesis.current?.speak(utterance);
        }, options.delay);
      } else {
        synthesis.current.speak(utterance);
      }
    });
  };

  /**
   * Add announcement to queue
   */
  const announce = useCallback((
    text: string,
    options: AnnouncementOptions = {}
  ) => {
    if (!screenReaderConfig.enabled) return;

    // Add to queue based on priority
    if (options.priority === 'high') {
      announcementQueue.current.unshift({ text, options });
    } else {
      announcementQueue.current.push({ text, options });
    }

    // Process queue
    processQueue();
  }, [screenReaderConfig.enabled, processQueue]);

  /**
   * Announce key press
   */
  const announceKey = useCallback((key: string) => {
    const keyName = key === ' ' ? 'space' : key;
    announce(keyName, { priority: 'high', interrupt: true });
  }, [announce]);

  /**
   * Announce error
   */
  const announceError = useCallback((key: string) => {
    announce(`Incorrect key: ${key}`, { priority: 'high', interrupt: true });
  }, [announce]);

  /**
   * Update screen reader configuration
   */
  const updateConfig = useCallback((newConfig: Partial<ScreenReaderConfig>) => {
    Object.assign(screenReaderConfig, newConfig);

    if (newConfig.voice || newConfig.language) {
      initializeVoice();
    }
  }, []);

  /**
   * Clear announcement queue
   */
  const clearQueue = useCallback(() => {
    if (synthesis.current) {
      synthesis.current.cancel();
    }
    announcementQueue.current = [];
    isProcessingQueue.current = false;
  }, []);

  return {
    isSupported,
    isReady,
    announce,
    announceKey,
    announceError,
    updateConfig,
    clearQueue,
    selectedVoice
  };
}```


🟦 File: src/hooks/use-haptic-feedback.ts
───────────────────────────────────────────────────
```ts
/*
 * ██╗  ██╗ █████╗ ██████╗ ████████╗██╗ ██████╗███████╗
 * ██║  ██║██╔══██╗██╔══██╗╚══██╔══╝██║██╔════╝██╔════╝
 * ███████║███████║██████╔╝   ██║   ██║██║     ███████╗
 * ██╔══██║██╔══██║██╔═══╝    ██║   ██║██║     ╚════██║
 * ██║  ██║██║  ██║██║        ██║   ██║╚██████╗███████║
 * ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝        ╚═╝   ╚═╝ ╚═════╝╚══════╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Hook: Haptic Feedback                                                                          ║
 * ║ Description: Custom hook for managing haptic feedback in the typing tutor                      ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { useCallback, useEffect, useRef, useState } from 'react';
import { HapticPattern } from '@/types/typing';

interface HapticConfig {
  enabled: boolean;
  intensity: number;
  customPatterns?: Record<string, HapticPattern>;
}

/**
 * Default haptic patterns
 */
const DEFAULT_PATTERNS: Record<string, HapticPattern> = {
  keyPress: {
    intensity: 0.5,
    duration: 50,
    pattern: [1],
    description: 'Standard key press feedback'
  },
  error: {
    intensity: 1.0,
    duration: 100,
    pattern: [1, 0, 1, 0, 1],
    description: 'Error feedback pattern'
  },
  success: {
    intensity: 0.7,
    duration: 150,
    pattern: [1, 0, 1],
    description: 'Success feedback pattern'
  },
  warning: {
    intensity: 0.8,
    duration: 75,
    pattern: [1, 0, 1],
    description: 'Warning feedback pattern'
  }
};

/**
 * Default configuration
 */
const DEFAULT_CONFIG: HapticConfig = {
  enabled: true,
  intensity: 1.0
};

/**
 * Custom hook for managing haptic feedback
 */
export function useHapticFeedback(config: Partial<HapticConfig> = {}) {
  // Merge default config with provided config
  const hapticConfig = { ...DEFAULT_CONFIG, ...config };

  // State for tracking support and patterns
  const [isSupported, setIsSupported] = useState(false);
  const [isReady, setIsReady] = useState(false);

  // Refs for tracking state and timing
  const lastTriggerTime = useRef<number>(0);
  const patterns = useRef<Record<string, HapticPattern>>({
    ...DEFAULT_PATTERNS,
    ...hapticConfig.customPatterns
  });

  /**
   * Initialize haptic feedback system
   */
  useEffect(() => {
    checkHapticSupport().then(supported => {
      setIsSupported(supported);
      setIsReady(true);

      if (supported) {
        console.log('Haptic feedback is supported');
      } else {
        console.warn('Haptic feedback is not supported on this device');
      }
    });
  }, []);

  /**
   * Check if haptic feedback is supported
   */
  const checkHapticSupport = async (): Promise<boolean> => {
    // Check for vibration API support
    if ('vibrate' in navigator) {
      try {
        // Test vibration
        await navigator.vibrate(0);
        return true;
      } catch (error) {
        console.error('Error testing vibration:', error);
        return false;
      }
    }
    return false;
  };

  /**
   * Trigger haptic feedback with a specific pattern
   */
  const triggerHapticFeedback = useCallback(async (
    pattern: HapticPattern,
    options: { force?: boolean; minInterval?: number } = {}
  ) => {
    if (!hapticConfig.enabled || !isSupported) return;

    const now = Date.now();
    const minInterval = options.minInterval || 50; // Default minimum interval

    // Check if enough time has passed since last trigger
    if (!options.force && now - lastTriggerTime.current < minInterval) {
      return;
    }

    try {
      // Apply intensity scaling
      const scaledPattern = pattern.pattern.map(value =>
        value === 0 ? 0 : Math.round(value * pattern.duration * hapticConfig.intensity)
      );

      // Trigger vibration
      await navigator.vibrate(scaledPattern);
      lastTriggerTime.current = now;

      console.log('Triggered haptic feedback:', {
        pattern: pattern.description,
        duration: pattern.duration,
        intensity: hapticConfig.intensity
      });
    } catch (error) {
      console.error('Error triggering haptic feedback:', error);
    }
  }, [hapticConfig.enabled, hapticConfig.intensity, isSupported]);

  /**
   * Add a custom haptic pattern
   */
  const addPattern = useCallback((
    id: string,
    pattern: HapticPattern
  ) => {
    patterns.current[id] = pattern;
    console.log(`Added custom haptic pattern: ${id}`, pattern);
  }, []);

  /**
   * Remove a custom haptic pattern
   */
  const removePattern = useCallback((id: string) => {
    if (id in DEFAULT_PATTERNS) {
      console.warn(`Cannot remove default pattern: ${id}`);
      return;
    }

    delete patterns.current[id];
    console.log(`Removed custom haptic pattern: ${id}`);
  }, []);

  /**
   * Get a specific haptic pattern
   */
  const getPattern = useCallback((id: string): HapticPattern | undefined => {
    return patterns.current[id];
  }, []);

  /**
   * Trigger a predefined haptic pattern
   */
  const triggerPattern = useCallback(async (
    patternId: string,
    options?: { force?: boolean; minInterval?: number }
  ) => {
    const pattern = getPattern(patternId);
    if (pattern) {
      await triggerHapticFeedback(pattern, options);
    } else {
      console.warn(`Haptic pattern not found: ${patternId}`);
    }
  }, [triggerHapticFeedback, getPattern]);

  /**
   * Create a composite haptic pattern from multiple patterns
   */
  const createCompositePattern = useCallback((
    patternIds: string[],
    spacing: number = 100
  ): HapticPattern => {
    const compositePattern: number[] = [];
    let totalDuration = 0;
    let description = 'Composite pattern: ';

    patternIds.forEach((id, index) => {
      const pattern = getPattern(id);
      if (pattern) {
        // Add spacing if not first pattern
        if (index > 0) {
          compositePattern.push(0);
          totalDuration += spacing;
        }

        // Add pattern
        compositePattern.push(...pattern.pattern);
        totalDuration += pattern.duration;
        description += `${pattern.description}, `;
      }
    });

    return {
      intensity: Math.max(...patternIds.map(id => getPattern(id)?.intensity || 0)),
      duration: totalDuration,
      pattern: compositePattern,
      description: description.slice(0, -2)
    };
  }, [getPattern]);

  return {
    isSupported,
    isReady,
    triggerHapticFeedback,
    triggerPattern,
    addPattern,
    removePattern,
    getPattern,
    createCompositePattern,
    patterns: patterns.current
  };
}```


🟦 File: src/components/AccessibleTypingTutor.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗██████╗ ██╗███╗   ██╗ ██████╗     ████████╗██╗   ██╗████████╗ ██████╗ ██████╗
 * ╚══██╔══╝╚██╗ ██╔╝██╔══██╗██║████╗  ██║██╔════╝     ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗
 *    ██║    ╚████╔╝ ██████╔╝██║██╔██╗ ██║██║  ███╗       ██║   ██║   ██║   ██║   ██║   ██║██████╔╝
 *    ██║     ╚██╔╝  ██╔═══╝ ██║██║╚██╗██║██║   ██║       ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗
 *    ██║      ██║   ██║     ██║██║ ╚████║╚██████╔╝       ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║
 *    ╚═╝      ╚═╝   ╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝        ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: AccessibleTypingTutor                                                               ║
 * ║ Description: Core typing tutor component with accessibility features, voice control,           ║
 * ║              and adaptive learning capabilities. Provides real-time feedback and analytics     ║
 * ║              for an enhanced typing learning experience.                                       ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import React, { useState, useEffect, useCallback, useRef } from "react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import { User } from "@supabase/supabase-js";
import { Volume2, VolumeX, Trophy } from "lucide-react";
import VisualKeyboard from "./VisualKeyboard";
import PerformanceChart from "./PerformanceChart";
import { analyzeTypingPatterns, generateAdaptiveLessons, type TypingAnalysis } from "@/utils/typingAnalytics";

const LESSON_SETS = {
  beginner: [
    "Hello world!",
    "The quick brown fox jumps over the lazy dog.",
    "Practice makes perfect.",
    "Type with confidence and accuracy.",
    "Keep your fingers on the home row keys.",
  ],
  intermediate: [
    "JavaScript is a popular programming language.",
    "React helps build interactive user interfaces.",
    "Programming requires attention to detail.",
    "Learning to type faster improves productivity.",
    "Good developers write clean, readable code.",
  ],
  advanced: [
    "The function takes a callback as an argument and executes it asynchronously.",
    "Object-oriented programming emphasizes code reusability and maintainability.",
    "TypeScript adds static typing to JavaScript for better development experience.",
    "Version control systems help teams collaborate on code effectively.",
    "Regular expressions are powerful tools for pattern matching in strings.",
  ],
};

declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
  }
}

interface TypingHistory {
  id: string;
  user_id: string;
  created_at: string;
  words_per_minute: number;
  accuracy_percentage: number;
  lesson_level: string;
}

const AccessibleTypingTutor = () => {
  const [text, setText] = useState("");
  const [target, setTarget] = useState("Press any key to begin");
  const [isListening, setIsListening] = useState(false);
  const [startTime, setStartTime] = useState<number | null>(null);
  const [errorCount, setErrorCount] = useState(0);
  const [feedback, setFeedback] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isTutorEnabled, setIsTutorEnabled] = useState(true);
  const [voiceIndex, setVoiceIndex] = useState(0);
  const [isMuted, setIsMuted] = useState(false);
  const [currentLevel, setCurrentLevel] = useState<'beginner' | 'intermediate' | 'advanced'>('beginner');
  const [lessonIndex, setLessonIndex] = useState(0);
  const [user, setUser] = useState<User | null>(null);
  const [stats, setStats] = useState<{ averageWpm: number; averageAccuracy: number } | null>(null);
  const [pressedKey, setPressedKey] = useState<string | null>(null);
  const [performanceHistory, setPerformanceHistory] = useState<Array<{
    date: string;
    wpm: number;
    accuracy: number;
  }>>([]);
  const [showWelcome, setShowWelcome] = useState(true);
  const [mistakes, setMistakes] = useState<Array<{ actual: string; expected: string }>>([]);
  const [recentWPMs, setRecentWPMs] = useState<number[]>([]);
  const [analysis, setAnalysis] = useState<TypingAnalysis | null>(null);
  const [streak, setStreak] = useState(0);

  const { toast } = useToast();
  const announcer = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const voices = useRef<SpeechSynthesisVoice[]>([]);

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      if (session?.user) {
        fetchUserStats(session.user.id);
      }
    });

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      if (session?.user) {
        fetchUserStats(session.user.id);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  const fetchUserStats = async (userId: string) => {
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('words_per_minute, accuracy_percentage')
      .eq('id', userId)
      .single();

    if (!error && profile) {
      setStats({
        averageWpm: profile.words_per_minute || 0,
        averageAccuracy: profile.accuracy_percentage || 0
      });
    }
  };

  useEffect(() => {
    const loadVoices = () => {
      voices.current = window.speechSynthesis.getVoices();
      const preferredVoice = voices.current.findIndex(
        voice => voice.name.includes('Natural') || voice.name.includes('Premium')
      );
      if (preferredVoice !== -1) {
        setVoiceIndex(preferredVoice);
      }
    };

    window.speechSynthesis.onvoiceschanged = loadVoices;
    loadVoices();

    return () => {
      window.speechSynthesis.onvoiceschanged = null;
    };
  }, []);

  const announce = (message: string) => {
    if (announcer.current) {
      announcer.current.textContent = message;
    }

    if (window.speechSynthesis && !isMuted) {
      window.speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(message);
      if (voices.current.length > 0) {
        utterance.voice = voices.current[voiceIndex];
        utterance.rate = 0.9; // Slightly slower for better clarity
        utterance.pitch = 1;
      }
      window.speechSynthesis.speak(utterance);
    }
  };

  const getNextLesson = () => {
    const currentLessons = LESSON_SETS[currentLevel];
    if (lessonIndex >= currentLessons.length - 1) {
      if (currentLevel === 'beginner') {
        setCurrentLevel('intermediate');
        setLessonIndex(0);
        return LESSON_SETS.intermediate[0];
      } else if (currentLevel === 'intermediate') {
        setCurrentLevel('advanced');
        setLessonIndex(0);
        return LESSON_SETS.advanced[0];
      } else {
        setLessonIndex(0);
        return currentLessons[0];
      }
    } else {
      setLessonIndex(prev => prev + 1);
      return currentLessons[lessonIndex + 1];
    }
  };

  const calculateResults = useCallback(async () => {
    if (!startTime || !user) return;

    const endTime = Date.now();
    const timeInMinutes = (endTime - startTime) / 1000 / 60;
    const wordsTyped = target.split(' ').length;
    const wpm = Math.round(wordsTyped / timeInMinutes);
    const accuracy = Math.round(((target.length - errorCount) / target.length) * 100);

    setRecentWPMs(prev => [...prev.slice(-9), wpm]);
    const newAnalysis = analyzeTypingPatterns(mistakes, [...recentWPMs, wpm]);
    setAnalysis(newAnalysis);

    if (accuracy > 90) {
      setStreak(prev => prev + 1);
    } else {
      setStreak(0);
    }

    const adaptiveLessons = generateAdaptiveLessons(newAnalysis, currentLevel);

    announce(`Lesson completed! Your speed was ${wpm} words per minute with ${accuracy}% accuracy.`);

    if (isTutorEnabled) {
      setIsLoading(true);
      try {
        const { data, error } = await supabase.functions.invoke('gemini-tutor', {
          body: {
            text,
            target,
            wpm,
            accuracy
          },
        });

        if (error) throw error;
        setFeedback(data.feedback);
        announce(data.feedback);
      } catch (error) {
        console.error('Error getting AI feedback:', error);
        toast({
          title: "Error getting AI feedback",
          description: "Could not get AI feedback at this time",
          variant: "destructive",
        });
      }
    }

    if (user) {
      try {
        const { error: profileError } = await supabase
          .from('profiles')
          .update({
            words_per_minute: wpm,
            accuracy_percentage: accuracy,
            last_lesson_date: new Date().toISOString()
          })
          .eq('id', user.id);

        const { error: historyError } = await supabase
          .from('typing_history')
          .insert({
            user_id: user.id,
            words_per_minute: wpm,
            accuracy_percentage: accuracy,
            lesson_level: currentLevel
          });

        if (profileError || historyError) {
          throw profileError || historyError;
        }

        setPerformanceHistory(prev => [...prev, {
          date: new Date().toISOString(),
          wpm,
          accuracy
        }]);

        await fetchUserStats(user.id);
      } catch (error) {
        console.error('Error saving results:', error);
        toast({
          title: "Error saving results",
          description: "Your progress couldn't be saved. Please try again.",
          variant: "destructive",
        });
      }
    }

    toast({
      title: "Lesson completed!",
      description: `Speed: ${wpm} WPM | Accuracy: ${accuracy}%`,
      duration: 5000,
    });

    setStartTime(null);
    setErrorCount(0);
    setText("");
    setTarget(getNextLesson());
    setIsLoading(false);
  }, [startTime, target, errorCount, text, toast, isTutorEnabled, user, currentLevel, mistakes, recentWPMs]);

  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;

    if (showWelcome) {
      setShowWelcome(false);
      setTarget(LESSON_SETS.beginner[0]);
      setText("");
      return;
    }

    if (!startTime) {
      setStartTime(Date.now());
      announce("Starting timer. Begin typing.");
    }

    if (target.startsWith(value)) {
      setText(value);
      if (value === target) {
        calculateResults();
      }
    } else {
      setErrorCount(prev => prev + 1);
      const expectedChar = target[text.length];
      const lastChar = value[value.length - 1];
      setMistakes(prev => [...prev, { actual: lastChar, expected: expectedChar }]);
      announce(`Incorrect. Expected ${expectedChar}, got ${lastChar}`);
      toast({
        title: "Incorrect key",
        description: `Expected "${expectedChar}" but got "${lastChar}"`,
        variant: "destructive",
        duration: 2000,
      });
    }
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (showWelcome) {
        setShowWelcome(false);
        setTarget(LESSON_SETS.beginner[0]);
        setText("");
      }
      setPressedKey(e.key);
    };

    const handleKeyUp = () => {
      setPressedKey(null);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [showWelcome]);

  const toggleVoiceControl = () => {
    setIsListening(prev => !prev);
    const message = isListening ? "Voice control disabled" : "Voice control enabled";
    announce(message);
  };

  useEffect(() => {
    if (!isListening) return;

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      announce("Speech recognition is not supported in this browser");
      setIsListening(false);
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;

    recognition.onstart = () => {
      announce("Voice recognition started");
    };

    recognition.onresult = (event) => {
      const transcript = Array.from(event.results)
        .map(result => result[0].transcript)
        .join(' ')
        .toLowerCase();

      console.log("Voice command detected:", transcript);

      if (transcript.includes('start')) {
        if (target.includes("Press any key")) {
          setTarget("Hello world!");
          setText("");
          setStartTime(Date.now());
          announce("Starting new lesson");
        }
      } else if (transcript.includes('stop') || transcript.includes('end')) {
        setIsListening(false);
        announce("Voice control disabled");
      }
    };

    recognition.onerror = (event) => {
      console.error('Speech recognition error:', event.error);
      announce("Voice recognition error. Please try again.");
    };

    try {
      recognition.start();
    } catch (error) {
      console.error('Error starting speech recognition:', error);
    }

    return () => {
      try {
        recognition.stop();
      } catch (error) {
        console.error('Error stopping speech recognition:', error);
      }
    };
  }, [isListening, target]);

  useEffect(() => {
    inputRef.current?.focus();
  }, [target]);

  useEffect(() => {
    const fetchPerformanceHistory = async () => {
      if (!user) return;

      const { data, error } = await supabase
        .from('typing_history')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: true });

      if (!error && data) {
        setPerformanceHistory(data.map((record: TypingHistory) => ({
          date: record.created_at,
          wpm: record.words_per_minute,
          accuracy: record.accuracy_percentage
        })));
      }
    };

    fetchPerformanceHistory();
  }, [user]);

  const getNextExpectedKey = () => {
    if (!target || text.length >= target.length) return null;
    return target[text.length];
  };

  return (
    <div className="min-h-screen bg-background text-foreground p-8 flex flex-col items-center justify-center space-y-8 animate-fade-in">
      <div
        ref={announcer}
        className="sr-only"
        role="status"
        aria-live="polite"
      />
      {showWelcome && (
        <div className="fixed inset-0 bg-background/95 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
          <div className="text-center space-y-4">
            <h1 className="text-4xl font-bold mb-8">Welcome to the Typing Tutor</h1>
            <p className="text-xl text-secondary animate-pulse">Press any key to begin</p>
          </div>
        </div>
      )}

      <div className="w-full max-w-2xl mb-8">
        <div className="flex justify-between items-center mb-6">
          <div className="flex gap-4">
            <button
              onClick={() => setIsListening(prev => !prev)}
              className={`p-3 rounded-lg transition-all duration-300 ${
                isListening ? "bg-primary/20 text-primary" : "bg-secondary/10"
              }`}
            >
              {isListening ? "🎤 Listening..." : "🎤"}
            </button>
            <button
              onClick={() => setIsMuted(prev => !prev)}
              className="p-3 rounded-lg bg-secondary/10"
            >
              {isMuted ? <VolumeX className="h-5 w-5" /> : <Volume2 className="h-5 w-5" />}
            </button>
          </div>
          {user && stats && (
            <div className="text-sm text-secondary">
              Average: {stats.averageWpm} WPM | {stats.averageAccuracy}% accuracy
            </div>
          )}
          {streak > 0 && (
            <div className="flex items-center gap-2 text-primary animate-scale-in">
              <Trophy className="h-5 w-5" />
              <span>Streak: {streak}</span>
            </div>
          )}
          {analysis && (
            <div className="text-sm text-secondary">
              Consistency: {analysis.consistencyScore}%
            </div>
          )}
        </div>

        <div className="space-y-8 p-8 rounded-lg border border-border/50 bg-black/30 backdrop-blur-sm">
          <div className="relative">
            <p className="text-4xl font-mono text-secondary mb-4 transition-all duration-300">
              {target}
            </p>
            <div className="h-px bg-border/50 my-8" />
            <div className="relative">
              <input
                ref={inputRef}
                type="text"
                value={text}
                onChange={handleInput}
                className="w-full bg-transparent text-4xl font-mono focus:outline-none focus:ring-0 transition-all duration-300"
                style={{
                  caretColor: 'currentcolor',
                  animation: 'cursor-blink 1s step-end infinite'
                }}
                autoComplete="off"
                autoCapitalize="off"
                autoCorrect="off"
                spellCheck="false"
              />
              <div
                className="absolute bottom-0 left-0 w-full h-0.5 bg-primary/50 origin-left transition-transform duration-300"
                style={{
                  transform: `scaleX(${text.length / target.length})`
                }}
              />
            </div>
          </div>
        </div>
      </div>

      <div className="w-full max-w-6xl mt-8">
        <VisualKeyboard
          pressedKey={pressedKey}
          nextKey={getNextExpectedKey()}
        />
      </div>

      {user && performanceHistory.length > 0 && (
        <div className="w-full max-w-6xl">
          <h2 className="text-xl font-semibold mb-4">Your Progress</h2>
          <PerformanceChart data={performanceHistory} />
        </div>
      )}

      {analysis && (
        <div className="w-full max-w-2xl p-4 rounded-lg border border-border/50 bg-black/30 backdrop-blur-sm">
          <h3 className="text-lg font-semibold mb-4">Typing Analysis</h3>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <h4 className="font-medium mb-2">Common Mistakes</h4>
              <ul className="space-y-2">
                {analysis.commonMistakes.map((mistake, i) => (
                  <li key={i} className="text-sm text-secondary">
                    Typed "{mistake.character}" instead of "{mistake.expectedChar}" ({mistake.count}x)
                  </li>
                ))}
              </ul>
            </div>
            <div>
              <h4 className="font-medium mb-2">Problem Keys</h4>
              <div className="flex flex-wrap gap-2">
                {analysis.problemKeys.map((key, i) => (
                  <span key={i} className="px-2 py-1 rounded-md bg-destructive/20 text-destructive text-sm">
                    {key}
                  </span>
                ))}
              </div>
            </div>
          </div>
        </div>
      )}

      {feedback && isTutorEnabled && (
        <div
          className="p-4 rounded-lg border border-primary/50 bg-primary/5"
          role="alert"
          aria-live="polite"
        >
          <h2 className="text-lg font-semibold mb-2">AI Feedback</h2>
          <p className="text-secondary">{feedback}</p>
        </div>
      )}

      {isLoading && isTutorEnabled && (
        <div
          className="text-center text-secondary animate-pulse"
          role="alert"
          aria-live="polite"
        >
          Getting AI feedback...
        </div>
      )}

      <div
        id="typing-instructions"
        className="mt-8 text-center text-secondary animate-slide-up"
      >
        <p>Press Tab to navigate, Space to select, and use arrow keys for navigation.</p>
        <p>Voice commands: Say "start" to begin, "stop" to disable voice control.</p>
      </div>
    </div>
  );
};

export default AccessibleTypingTutor;
```


🟦 File: src/ai/adapters/base.adapter.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Interface: AI Adapter Base                                                                     ║
 * ║ Description: Base interface for AI model adapters (Gemini, GPT-4, etc.)                       ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

export interface AIConfig {
  model: string;
  temperature: number;
  maxTokens: number;
  streamCallback?: (text: string) => void;
}

export interface AIResponse {
  text: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  metadata?: Record<string, unknown>;
}

export interface AIAdapter {
  /**
   * Initialize the AI adapter with configuration
   * @param config The AI model configuration
   */
  initialize(config: AIConfig): Promise<void>;

  /**
   * Generate content based on a prompt
   * @param prompt The input prompt
   * @returns The generated content
   */
  generateContent(prompt: string): Promise<string>;

  /**
   * Stream content generation
   * @param prompt The input prompt
   * @param onToken Callback for each token
   */
  streamContent(prompt: string, onToken: (token: string) => void): Promise<void>;

  /**
   * Get the model's configuration
   */
  getConfig(): AIConfig;

  /**
   * Get usage statistics
   */
  getUsage(): Promise<{
    tokensUsed: number;
    requestsMade: number;
    lastRequestTime: Date;
  }>;
}```


🟦 File: src/lib/gemini-tutor.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Gemini Tutor                                                                           ║
 * ║ Description: Real-time AI tutoring using Gemini 2.0 Flash with multimodal capabilities        ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai';
import { getConfig } from './config';

interface TutorConfig {
  enableStreaming?: boolean;
  enableVoice?: boolean;
  enableScreenShare?: boolean;
  onStreamUpdate?: (text: string) => void;
  onError?: (error: Error) => void;
}

interface TutorFeedback {
  feedback: string;
  corrections: Array<{
    mistake: string;
    suggestion: string;
    explanation: string;
  }>;
  nextSteps: string[];
  confidenceScore: number;
}

interface PerformanceMetrics {
  wpm: number;
  accuracy: number;
  consistency: number;
  problemAreas: string[];
  recentMistakes: Array<{ actual: string; expected: string }>;
}

// Add ImageCapture type definition
declare global {
  class ImageCapture {
    constructor(track: MediaStreamTrack);
    grabFrame(): Promise<ImageBitmap>;
  }
}

export class GeminiTutor {
  private genAI: GoogleGenerativeAI;
  private model: GenerativeModel;
  private config: TutorConfig;
  private screenCapture: MediaStream | null = null;
  private mediaRecorder: MediaRecorder | null = null;
  private recordedChunks: Blob[] = [];

  constructor(config: TutorConfig = {}) {
    const { googleAiApiKey } = getConfig();
    this.genAI = new GoogleGenerativeAI(googleAiApiKey);
    this.model = this.genAI.getGenerativeModel({
      model: "gemini-2.0-flash",
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 2048,
      },
    });
    this.config = config;

    // Initialize screen capture if enabled
    if (config.enableScreenShare) {
      this.initializeScreenCapture();
    }
  }

  private async initializeScreenCapture() {
    try {
      this.screenCapture = await navigator.mediaDevices.getDisplayMedia({
        video: {
          displaySurface: "monitor",
        },
        audio: false,
      });

      this.mediaRecorder = new MediaRecorder(this.screenCapture, {
        mimeType: 'video/webm;codecs=vp9',
      });

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };

      this.mediaRecorder.start(1000); // Capture every second
    } catch (error) {
      console.error('Failed to initialize screen capture:', error);
      this.config.onError?.(error as Error);
    }
  }

  private async getScreenshot(): Promise<string | null> {
    if (!this.screenCapture) return null;

    const videoTrack = this.screenCapture.getVideoTracks()[0];
    const imageCapture = new ImageCapture(videoTrack);

    try {
      const bitmap = await imageCapture.grabFrame();
      const canvas = document.createElement('canvas');
      canvas.width = bitmap.width;
      canvas.height = bitmap.height;

      const context = canvas.getContext('2d');
      if (!context) return null;

      context.drawImage(bitmap, 0, 0);
      return canvas.toDataURL('image/jpeg', 0.8);
    } catch (error) {
      console.error('Failed to capture screenshot:', error);
      return null;
    }
  }

  public async provideFeedback(
    currentText: string,
    targetText: string,
    metrics: PerformanceMetrics
  ): Promise<TutorFeedback> {
    try {
      const screenshot = this.config.enableScreenShare ? await this.getScreenshot() : null;

      const prompt = `
        As a typing tutor, analyze:
        Current text: "${currentText}"
        Target text: "${targetText}"

        Performance Metrics:
        - WPM: ${metrics.wpm}
        - Accuracy: ${metrics.accuracy}%
        - Consistency: ${metrics.consistency}%
        - Recent Mistakes: ${JSON.stringify(metrics.recentMistakes)}
        - Problem Areas: ${metrics.problemAreas.join(', ')}

        ${screenshot ? 'I am also providing a screenshot of the user\'s typing interface for context.' : ''}

        Please provide:
        1. Specific feedback on typing technique and errors
        2. Detailed corrections for recent mistakes
        3. Actionable next steps for improvement
        4. A confidence score for this assessment

        Format the response as a JSON object with the following structure:
        {
          "feedback": "main feedback message",
          "corrections": [{"mistake": "...", "suggestion": "...", "explanation": "..."}],
          "nextSteps": ["step1", "step2", "..."],
          "confidenceScore": 0.95
        }
      `;

      const result = await this.model.generateContent({
        contents: [
          {
            role: "user",
            parts: [
              { text: prompt },
              ...(screenshot ? [{ inlineData: { data: screenshot, mimeType: "image/jpeg" } }] : []),
            ],
          },
        ],
      });

      const response = await result.response;
      const text = response.text();

      // Stream the response if streaming is enabled
      if (this.config.enableStreaming && this.config.onStreamUpdate) {
        this.config.onStreamUpdate(text);
      }

      try {
        const parsedResponse = JSON.parse(text) as TutorFeedback;
        return parsedResponse;
      } catch (error) {
        console.error('Failed to parse Gemini response:', error);
        return {
          feedback: text,
          corrections: [],
          nextSteps: [],
          confidenceScore: 0.5,
        };
      }
    } catch (error) {
      console.error('Error getting AI feedback:', error);
      this.config.onError?.(error as Error);
      return {
        feedback: "I'm having trouble analyzing your typing at the moment. Please continue practicing.",
        corrections: [],
        nextSteps: ["Focus on accuracy", "Maintain a steady rhythm"],
        confidenceScore: 0,
      };
    }
  }

  public async generateLesson(
    level: number,
    recentMistakes: Array<{ actual: string; expected: string }>,
    performanceHistory: Array<{ wpm: number; accuracy: number }>
  ): Promise<string> {
    try {
      const prompt = `
        Generate a typing lesson appropriate for:
        - Skill Level: ${level}/10
        - Recent Mistakes: ${JSON.stringify(recentMistakes)}
        - Performance History: ${JSON.stringify(performanceHistory)}

        Create a lesson that:
        1. Focuses on problem areas
        2. Gradually increases difficulty
        3. Includes common programming terms
        4. Maintains engagement

        The lesson should be 2-3 sentences long and include a mix of:
        - Common words
        - Problem characters
        - Programming concepts
      `;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      return response.text();
    } catch (error) {
      console.error('Error generating lesson:', error);
      this.config.onError?.(error as Error);
      return "The quick brown fox jumps over the lazy dog. Practice makes perfect.";
    }
  }

  public cleanup() {
    if (this.screenCapture) {
      this.screenCapture.getTracks().forEach(track => track.stop());
      this.screenCapture = null;
    }

    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
      this.mediaRecorder.stop();
      this.mediaRecorder = null;
    }

    this.recordedChunks = [];
  }
}

// Export a singleton instance for global use
export const geminiTutor = new GeminiTutor({
  enableStreaming: true,
  enableScreenShare: true,
  enableVoice: true,
  onStreamUpdate: (text) => console.info('AI Stream Update:', text),
  onError: (error) => console.error('AI Error:', error),
});```


🟦 File: src/lib/config.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Configuration                                                                          ║
 * ║ Description: Environment configuration loader and validator for DeepType                       ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { z } from 'zod';

// Configuration schema for type-safe environment variables
const configSchema = z.object({
  // AI Configuration
  openaiApiKey: z.string().min(1, 'OpenAI API key is required'),
  googleAiApiKey: z.string().min(1, 'Google AI API key is required'),
  aiModel: z.enum(['gpt-4', 'gpt-3.5-turbo', 'gemini-pro', 'gemini-2.0-flash']),
  aiTemperature: z.number().min(0).max(1),
  aiMaxTokens: z.number().positive(),

  // Supabase Configuration
  supabaseUrl: z.string().url('Invalid Supabase URL'),
  supabaseAnonKey: z.string().min(1, 'Supabase anonymous key is required'),

  // Feature Flags
  enableVoiceCommands: z.boolean(),
  enableHapticFeedback: z.boolean(),
  enableRealTimeAnalysis: z.boolean(),

  // Analytics Configuration
  enablePerformanceTracking: z.boolean(),
  enableErrorTracking: z.boolean(),
  analyticsSampleRate: z.number().min(0).max(100),
});

// Type inference from schema
export type Config = z.infer<typeof configSchema>;

// Configuration loader with validation
export function loadConfig(): Config {
  try {
    // Load and validate configuration
    const config = configSchema.parse({
      openaiApiKey: process.env.OPENAI_API_KEY,
      googleAiApiKey: process.env.GOOGLE_AI_API_KEY,
      aiModel: process.env.AI_MODEL || 'gemini-pro',
      aiTemperature: Number(process.env.AI_TEMPERATURE || 0.7),
      aiMaxTokens: Number(process.env.AI_MAX_TOKENS || 2048),
      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
      supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      enableVoiceCommands: process.env.ENABLE_VOICE_COMMANDS === 'true',
      enableHapticFeedback: process.env.ENABLE_HAPTIC_FEEDBACK === 'true',
      enableRealTimeAnalysis: process.env.ENABLE_REAL_TIME_ANALYSIS === 'true',
      enablePerformanceTracking: process.env.ENABLE_PERFORMANCE_TRACKING === 'true',
      enableErrorTracking: process.env.ENABLE_ERROR_TRACKING === 'true',
      analyticsSampleRate: Number(process.env.ANALYTICS_SAMPLE_RATE || 100),
    });

    // Log configuration for debugging (excluding sensitive values)
    console.info('Configuration loaded:', {
      aiModel: config.aiModel,
      aiTemperature: config.aiTemperature,
      aiMaxTokens: config.aiMaxTokens,
      enableVoiceCommands: config.enableVoiceCommands,
      enableHapticFeedback: config.enableHapticFeedback,
      enableRealTimeAnalysis: config.enableRealTimeAnalysis,
      enablePerformanceTracking: config.enablePerformanceTracking,
      enableErrorTracking: config.enableErrorTracking,
      analyticsSampleRate: config.analyticsSampleRate,
    });

    return config;
  } catch (error) {
    console.error('Configuration validation failed:', error);
    throw new Error('Failed to load configuration. Check your environment variables.');
  }
}

// Singleton instance for configuration
let config: Config | null = null;

// Get configuration, initializing if necessary
export function getConfig(): Config {
  if (!config) {
    config = loadConfig();
  }
  return config;
}

// Reset configuration (useful for testing)
export function resetConfig(): void {
  config = null;
}

// Validate specific configuration subset
export function validateConfig<T extends Partial<Config>>(
  partialConfig: T,
  schema: z.ZodType<T>
): T {
  return schema.parse(partialConfig);
}```


🟦 File: src/lib/ai-utils.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: AI Utilities                                                                           ║
 * ║ Description: Utility functions for initializing and managing AI components                     ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { SupabaseClient } from '@supabase/supabase-js';
import { AICore, AIConfig, TutorResponse } from './ai-core';
import { getConfig } from './config';

// Singleton instance of AICore
let aiCoreInstance: AICore | null = null;

/**
 * Initialize the AI Core with proper configuration
 * @param supabase - Supabase client instance
 * @param streamCallback - Optional callback for streaming responses
 * @returns Initialized AICore instance
 */
export function initializeAICore(
  supabase: SupabaseClient,
  streamCallback?: (text: string) => void
): AICore {
  if (aiCoreInstance) {
    console.info('Reusing existing AI Core instance');
    return aiCoreInstance;
  }

  const config = getConfig();

  const aiConfig: AIConfig = {
    model: config.aiModel,
    temperature: config.aiTemperature,
    maxTokens: config.aiMaxTokens,
    streamCallback
  };

  console.info('Initializing new AI Core with config:', {
    model: aiConfig.model,
    temperature: aiConfig.temperature,
    maxTokens: aiConfig.maxTokens,
    hasStreamCallback: !!streamCallback
  });

  aiCoreInstance = new AICore(supabase, aiConfig);
  return aiCoreInstance;
}

/**
 * Reset the AI Core instance (useful for testing or reconfiguration)
 */
export function resetAICore(): void {
  aiCoreInstance = null;
  console.info('AI Core instance has been reset');
}

/**
 * Get the current AI Core instance, initializing if necessary
 * @param supabase - Supabase client instance
 * @param streamCallback - Optional callback for streaming responses
 * @returns AICore instance
 */
export function getAICore(
  supabase: SupabaseClient,
  streamCallback?: (text: string) => void
): AICore {
  return aiCoreInstance || initializeAICore(supabase, streamCallback);
}

/**
 * Format tutor response for display
 * @param response - Raw tutor response
 * @returns Formatted response object
 */
export function formatTutorResponse(response: TutorResponse): {
  message: string;
  hints: string[];
  confidence: number;
} {
  return {
    message: response.feedback,
    hints: response.adaptiveHints || [],
    confidence: response.confidenceScore || 0.5
  };
}

/**
 * Calculate typing accuracy percentage
 * @param mistakes - Array of typing mistakes
 * @param totalCharacters - Total characters typed
 * @returns Accuracy percentage
 */
export function calculateAccuracy(
  mistakes: Array<{ actual: string; expected: string }>,
  totalCharacters: number
): number {
  if (totalCharacters === 0) return 100;
  const errorCount = mistakes.length;
  return Math.round(((totalCharacters - errorCount) / totalCharacters) * 100);
}

/**
 * Calculate words per minute (WPM)
 * @param characterCount - Number of characters typed
 * @param timeInSeconds - Time taken in seconds
 * @returns WPM calculation
 */
export function calculateWPM(characterCount: number, timeInSeconds: number): number {
  if (timeInSeconds === 0) return 0;
  // Standard calculation: 5 characters = 1 word
  const wordsTyped = characterCount / 5;
  const minutes = timeInSeconds / 60;
  return Math.round(wordsTyped / minutes);
}

/**
 * Generate a typing challenge appropriate for the user's level
 * @param userLevel - Current user level (1-10)
 * @param previousMistakes - Array of previous mistakes
 * @returns Challenge text and metadata
 */
export async function generateChallenge(
  userLevel: number,
  previousMistakes: Array<{ actual: string; expected: string }> = []
): Promise<{
  text: string;
  difficulty: number;
  focusAreas: string[];
}> {
  // Fallback content if AI generation fails
  const fallbackChallenges = [
    { text: 'The quick brown fox jumps over the lazy dog.', difficulty: 1 },
    { text: 'Pack my box with five dozen liquor jugs.', difficulty: 2 },
    { text: 'How vexingly quick daft zebras jump!', difficulty: 3 },
    { text: 'The five boxing wizards jump quickly.', difficulty: 4 },
    { text: 'Sphinx of black quartz, judge my vow.', difficulty: 5 }
  ];

  try {
    const ai = aiCoreInstance;
    if (!ai) {
      throw new Error('AI Core not initialized');
    }

    const lessonContent = await ai.generateLessonContent(
      userLevel,
      previousMistakes.map(m => `${m.actual} -> ${m.expected}`),
      'adaptive'
    );

    return {
      text: lessonContent,
      difficulty: userLevel,
      focusAreas: previousMistakes.map(m => m.expected)
    };
  } catch (error) {
    console.error('Failed to generate challenge:', error);
    const fallback = fallbackChallenges[Math.min(userLevel - 1, fallbackChallenges.length - 1)];
    return {
      text: fallback.text,
      difficulty: fallback.difficulty,
      focusAreas: ['accuracy', 'speed']
    };
  }
}```


🟦 File: src/lib/ai-core.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: AI Core                                                                                ║
 * ║ Description: Core AI module providing real-time tutoring capabilities using Gemini 2.0 Flash   ║
 * ║              and OpenAI, with streaming responses and adaptive learning features.              ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import OpenAI from 'openai';
import { SupabaseClient } from '@supabase/supabase-js';
import {
  GoogleGenerativeAI,
  GenerativeModel,
  GenerateContentResult,
  GenerateContentStreamResult
} from '@google/generative-ai';
import { getConfig, Config } from './config';

export interface AIConfig {
  model: 'gpt-4' | 'gpt-3.5-turbo' | 'gemini-pro' | 'gemini-2.0-flash';
  temperature: number;
  maxTokens: number;
  streamCallback?: (text: string) => void;
}

export interface TutorResponse {
  feedback: string;
  nextLesson?: string;
  adaptiveHints?: string[];
  confidenceScore?: number;
}

export interface TypingAnalysis {
  errorPatterns: Array<{
    pattern: string;
    frequency: number;
    suggestion: string;
  }>;
  speedTrends: Array<{
    timestamp: string;
    wpm: number;
  }>;
  recommendedFocus: string[];
}

export class AICore {
  private openai: OpenAI;
  private genAI: GoogleGenerativeAI;
  private geminiModel: GenerativeModel;
  private supabase: SupabaseClient;
  private config: Config;
  private aiConfig: AIConfig;

  constructor(supabase: SupabaseClient, aiConfig: AIConfig) {
    this.config = getConfig();
    this.aiConfig = aiConfig;
    this.openai = new OpenAI({ apiKey: this.config.openaiApiKey });
    this.genAI = new GoogleGenerativeAI(this.config.googleAiApiKey);
    this.geminiModel = this.genAI.getGenerativeModel({
      model: aiConfig.model.startsWith('gemini') ? aiConfig.model : 'gemini-pro'
    });
    this.supabase = supabase;

    // Log initialization for debugging
    console.info('Initializing AI Core with config:', {
      model: aiConfig.model,
      temperature: aiConfig.temperature,
      maxTokens: aiConfig.maxTokens,
      hasStreamCallback: !!aiConfig.streamCallback,
      enableRealTimeAnalysis: this.config.enableRealTimeAnalysis,
      enableVoiceCommands: this.config.enableVoiceCommands
    });
  }

  async generateLessonContent(
    userLevel: number,
    previousMistakes: string[],
    learningStyle: string
  ): Promise<string> {
    if (!this.config.enableRealTimeAnalysis) {
      console.warn('Real-time analysis is disabled. Using fallback content generation.');
      return this.generateFallbackContent(userLevel);
    }

    console.info('Generating adaptive lesson content:', {
      level: userLevel,
      mistakeCount: previousMistakes.length,
      style: learningStyle
    });

    try {
      if (this.config.aiModel.startsWith('gemini')) {
        const prompt = `Generate a typing lesson for a user at level ${userLevel}.
                       Previous mistakes: ${previousMistakes.join(', ')}.
                       Learning style: ${learningStyle}`;

        if (this.aiConfig.streamCallback) {
          const streamResult = await this.geminiModel.generateContentStream(prompt);
          let fullContent = '';

          for await (const chunk of streamResult.stream) {
            const chunkText = chunk.text();
            fullContent += chunkText;
            this.aiConfig.streamCallback(chunkText);
          }

          return fullContent;
        } else {
          const result = await this.geminiModel.generateContent(prompt);
          return result.response.text();
        }
      } else {
        const response = await this.openai.chat.completions.create({
          model: this.config.aiModel,
          messages: [
            {
              role: 'system',
              content: 'You are an expert typing tutor focused on accessibility.'
            },
            {
              role: 'user',
              content: `Generate a typing lesson for a user at level ${userLevel}.
                       Previous mistakes: ${previousMistakes.join(', ')}.
                       Learning style: ${learningStyle}`
            }
          ],
          temperature: this.config.aiTemperature,
          max_tokens: this.config.aiMaxTokens,
          stream: !!this.aiConfig.streamCallback
        });

        if (this.aiConfig.streamCallback && response.hasOwnProperty('on')) {
          const stream = response as any;
          let fullContent = '';

          await new Promise((resolve, reject) => {
            stream.on('data', (chunk: any) => {
              const content = chunk.choices[0]?.delta?.content || '';
              fullContent += content;
              this.aiConfig.streamCallback?.(content);
            });

            stream.on('end', resolve);
            stream.on('error', reject);
          });

          return fullContent;
        } else {
          return (response as OpenAI.Chat.Completions.ChatCompletion).choices[0]?.message?.content || '';
        }
      }
    } catch (error) {
      console.error('Error generating lesson content:', error);
      return this.generateFallbackContent(userLevel);
    }
  }

  private generateFallbackContent(userLevel: number): string {
    const basicLessons = [
      'Practice typing home row keys: asdf jkl;',
      'Type common words: the, and, that, have',
      'Practice numbers and symbols: 1234567890',
      'Focus on capital letters and punctuation',
      'Type complete sentences with proper form'
    ];

    return basicLessons[Math.min(userLevel - 1, basicLessons.length - 1)];
  }

  async provideTutoring(
    currentText: string,
    targetText: string,
    recentMistakes: Array<{ actual: string; expected: string }>,
    userLevel: number
  ): Promise<TutorResponse> {
    if (!this.config.enableRealTimeAnalysis) {
      return {
        feedback: 'Real-time analysis is currently disabled.',
        confidenceScore: 0.5
      };
    }

    console.info('Providing real-time tutoring feedback:', {
      textLength: currentText.length,
      targetLength: targetText.length,
      mistakeCount: recentMistakes.length,
      level: userLevel
    });

    try {
      const prompt = `As a typing tutor, analyze:
                     Current text: "${currentText}"
                     Target text: "${targetText}"
                     Recent mistakes: ${JSON.stringify(recentMistakes)}
                     User level: ${userLevel}

                     Provide feedback in JSON format with:
                     - feedback: Main feedback message
                     - nextLesson: Suggested next lesson content
                     - adaptiveHints: Array of specific hints
                     - confidenceScore: Number between 0-1`;

      if (this.aiConfig.streamCallback) {
        const result = await this.geminiModel.generateContentStream(prompt);
        let fullResponse = '';

        for await (const chunk of result.stream) {
          const chunkText = chunk.text();
          fullResponse += chunkText;
          this.aiConfig.streamCallback(chunkText);
        }

        return JSON.parse(fullResponse);
      } else {
        const result = await this.geminiModel.generateContent(prompt);
        return JSON.parse(result.response.text());
      }
    } catch (error) {
      console.error('Error providing tutoring:', error);
      return {
        feedback: "I'm having trouble analyzing your typing. Let's continue with the current lesson.",
        confidenceScore: 0.5
      };
    }
  }

  async analyzeTypingPatterns(
    recentMistakes: Array<{ actual: string; expected: string }>,
    speedHistory: number[]
  ): Promise<TypingAnalysis> {
    if (!this.config.enableRealTimeAnalysis) {
      return {
        errorPatterns: [],
        speedTrends: [],
        recommendedFocus: ['Real-time analysis is currently disabled.']
      };
    }

    console.info('Analyzing typing patterns:', {
      mistakeCount: recentMistakes.length,
      speedDataPoints: speedHistory.length
    });

    try {
      const prompt = `Analyze typing patterns:
                     Mistakes: ${JSON.stringify(recentMistakes)}
                     Speed history (WPM): ${speedHistory.join(', ')}

                     Provide analysis in JSON format with:
                     - errorPatterns: Array of {pattern, frequency, suggestion}
                     - speedTrends: Array of {timestamp, wpm}
                     - recommendedFocus: Array of focus areas`;

      const result = await this.geminiModel.generateContent(prompt);
      const analysis: TypingAnalysis = JSON.parse(result.response.text());

      // Store analysis in Supabase for long-term pattern recognition
      if (this.config.enablePerformanceTracking) {
        await this.supabase
          .from('typing_analysis')
          .insert([{
            error_patterns: analysis.errorPatterns,
            speed_trends: analysis.speedTrends,
            recommended_focus: analysis.recommendedFocus,
            created_at: new Date().toISOString()
          }]);
      }

      return analysis;
    } catch (error) {
      console.error('Error analyzing typing patterns:', error);
      return {
        errorPatterns: [],
        speedTrends: [],
        recommendedFocus: ['Focus on accuracy and consistent speed']
      };
    }
  }

  // Utility method to update AI configuration
  updateConfig(newConfig: Partial<AIConfig>): void {
    this.config = { ...this.config, ...newConfig };
    console.info('Updated AI configuration:', {
      aiModel: this.config.aiModel,
      aiTemperature: this.config.aiTemperature,
      aiMaxTokens: this.config.aiMaxTokens,
      enableRealTimeAnalysis: this.config.enableRealTimeAnalysis
    });
  }
}```


🟦 File: src/lib/achievements.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Achievements                                                                           ║
 * ║ Description: Achievement system for tracking and unlocking user accomplishments                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import { SupabaseClient } from '@supabase/supabase-js';
import { useToast } from '@/components/ui/use-toast';
import { LucideIcon, Trophy, Zap, Target, Clock, Star, Award, Crown, Medal } from 'lucide-react';
import { createElement } from 'react';
import AchievementNotification from '@/components/achievements/AchievementNotification';

export interface Achievement {
  id: string;
  name: string;
  description: string;
  icon: keyof typeof ACHIEVEMENT_ICONS;
  criteria: AchievementCriteria;
  rarity: 'common' | 'rare' | 'epic' | 'legendary';
}

export interface AchievementCriteria {
  type: 'wpm' | 'accuracy' | 'lessons' | 'streak' | 'practice_time' | 'perfect_score';
  threshold: number;
  comparison: 'gte' | 'eq' | 'lte';
}

export interface AchievementProgress {
  achievementId: string;
  progress: number;
  isUnlocked: boolean;
  unlockedAt?: string;
}

export const ACHIEVEMENT_ICONS = {
  Zap,
  Target,
  Trophy,
  Clock,
  Star,
  Award,
  Crown,
  Medal
} as const;

// Define achievements with their criteria
export const ACHIEVEMENTS: Achievement[] = [
  {
    id: 'speed_demon',
    name: 'Speed Demon',
    description: 'Reach 100 WPM in a typing session',
    icon: 'Zap',
    criteria: {
      type: 'wpm',
      threshold: 100,
      comparison: 'gte'
    },
    rarity: 'epic'
  },
  {
    id: 'perfect_accuracy',
    name: 'Perfectionist',
    description: 'Complete a lesson with 100% accuracy',
    icon: 'Target',
    criteria: {
      type: 'accuracy',
      threshold: 100,
      comparison: 'eq'
    },
    rarity: 'rare'
  },
  {
    id: 'practice_master',
    name: 'Practice Master',
    description: 'Complete 50 typing lessons',
    icon: 'Trophy',
    criteria: {
      type: 'lessons',
      threshold: 50,
      comparison: 'gte'
    },
    rarity: 'common'
  },
  {
    id: 'consistency_king',
    name: 'Consistency King',
    description: 'Maintain a 10-day practice streak',
    icon: 'Crown',
    criteria: {
      type: 'streak',
      threshold: 10,
      comparison: 'gte'
    },
    rarity: 'rare'
  },
  {
    id: 'dedication',
    name: 'Dedication',
    description: 'Practice for a total of 24 hours',
    icon: 'Clock',
    criteria: {
      type: 'practice_time',
      threshold: 24,
      comparison: 'gte'
    },
    rarity: 'epic'
  },
  {
    id: 'flawless_victory',
    name: 'Flawless Victory',
    description: 'Complete an advanced lesson with 100% accuracy and 100+ WPM',
    icon: 'Star',
    criteria: {
      type: 'perfect_score',
      threshold: 1,
      comparison: 'gte'
    },
    rarity: 'legendary'
  }
];

export class AchievementManager {
  private supabase: SupabaseClient;
  private userId: string;
  private toast: ReturnType<typeof useToast>['toast'];

  constructor(supabase: SupabaseClient, userId: string, toast: ReturnType<typeof useToast>['toast']) {
    this.supabase = supabase;
    this.userId = userId;
    this.toast = toast;
  }

  private getIconComponent(iconName: keyof typeof ACHIEVEMENT_ICONS): LucideIcon {
    return ACHIEVEMENT_ICONS[iconName];
  }

  private async checkAchievementCriteria(
    criteria: AchievementCriteria,
    stats: {
      wpm: number;
      accuracy: number;
      lessons: number;
      streak: number;
      practiceTime: number;
      isPerfectScore: boolean;
    }
  ): Promise<boolean> {
    const value = criteria.type === 'perfect_score'
      ? stats.isPerfectScore
      : stats[criteria.type === 'practice_time' ? 'practiceTime' : criteria.type];

    if (typeof value === 'boolean') {
      return value;
    }

    switch (criteria.comparison) {
      case 'gte':
        return value >= criteria.threshold;
      case 'eq':
        return value === criteria.threshold;
      case 'lte':
        return value <= criteria.threshold;
      default:
        return false;
    }
  }

  public async checkAndUnlockAchievements(stats: {
    wpm: number;
    accuracy: number;
    lessons: number;
    streak: number;
    practiceTime: number;
    isPerfectScore: boolean;
  }): Promise<void> {
    try {
      // Get already unlocked achievements
      const { data: unlockedAchievements } = await this.supabase
        .from('user_achievements')
        .select('achievement_id')
        .eq('user_id', this.userId);

      const unlockedIds = new Set(unlockedAchievements?.map(ua => ua.achievement_id) || []);

      // Check each achievement
      for (const achievement of ACHIEVEMENTS) {
        if (unlockedIds.has(achievement.id)) continue;

        const isUnlocked = await this.checkAchievementCriteria(achievement.criteria, stats);
        if (isUnlocked) {
          // Unlock the achievement
          const { error } = await this.supabase
            .from('user_achievements')
            .insert({
              user_id: this.userId,
              achievement_id: achievement.id,
              unlocked_at: new Date().toISOString()
            });

          if (error) throw error;

          // Show notification
          const IconComponent = this.getIconComponent(achievement.icon);
          this.toast({
            title: '🏆 Achievement Unlocked!',
            description: createElement(AchievementNotification, {
              name: achievement.name,
              description: achievement.description,
              icon: IconComponent,
              rarity: achievement.rarity
            }),
            duration: 5000,
          });
        }
      }
    } catch (error) {
      console.error('Error checking achievements:', error);
      this.toast({
        title: 'Error',
        description: 'Failed to check achievements',
        variant: 'destructive',
      });
    }
  }

  public async getProgress(): Promise<AchievementProgress[]> {
    try {
      // Get user stats
      const { data: stats, error: statsError } = await this.supabase
        .from('profiles')
        .select('average_wpm, average_accuracy, total_lessons_completed, total_practice_time')
        .eq('id', this.userId)
        .single();

      if (statsError) throw statsError;

      // Get unlocked achievements
      const { data: unlockedAchievements, error: achievementsError } = await this.supabase
        .from('user_achievements')
        .select('achievement_id, unlocked_at')
        .eq('user_id', this.userId);

      if (achievementsError) throw achievementsError;

      const unlockedMap = new Map(
        unlockedAchievements?.map(ua => [ua.achievement_id, ua.unlocked_at]) || []
      );

      // Calculate progress for each achievement
      return ACHIEVEMENTS.map(achievement => {
        const unlockedAt = unlockedMap.get(achievement.id);
        let progress = 0;

        switch (achievement.criteria.type) {
          case 'wpm':
            progress = (stats.average_wpm / achievement.criteria.threshold) * 100;
            break;
          case 'accuracy':
            progress = (stats.average_accuracy / achievement.criteria.threshold) * 100;
            break;
          case 'lessons':
            progress = (stats.total_lessons_completed / achievement.criteria.threshold) * 100;
            break;
          case 'practice_time':
            progress = ((stats.total_practice_time / 60) / achievement.criteria.threshold) * 100;
            break;
          default:
            progress = unlockedAt ? 100 : 0;
        }

        return {
          achievementId: achievement.id,
          progress: Math.min(Math.round(progress), 100),
          isUnlocked: !!unlockedAt,
          unlockedAt
        };
      });
    } catch (error) {
      console.error('Error getting achievement progress:', error);
      throw error;
    }
  }
}

// Export a function to create the achievement manager
export function createAchievementManager(
  supabase: SupabaseClient,
  userId: string,
  toast: ReturnType<typeof useToast>['toast']
): AchievementManager {
  return new AchievementManager(supabase, userId, toast);
}```


🟦 File: src/lib/accessibility-core.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗██████╗ ██╗███╗   ██╗ ██████╗      █████╗ ██╗
 * ╚══██╔══╝╚██╗ ██╔╝██╔══██╗██║████╗  ██║██╔════╝     ██╔══██╗██║
 *    ██║    ╚████╔╝ ██████╔╝██║██╔██╗ ██║██║  ███╗    ███████║██║
 *    ██║     ╚██╔╝  ██╔═══╝ ██║██║╚██╗██║██║   ██║    ██╔══██║██║
 *    ██║      ██║   ██║     ██║██║ ╚████║╚██████╔╝    ██║  ██║██║
 *    ╚═╝      ╚═╝   ╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝     ╚═╝  ╚═╝╚═╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: AccessibilityCore                                                                      ║
 * ║ Description: Core accessibility module providing voice commands, haptic feedback, and          ║
 * ║              advanced error handling for an enhanced typing experience.                        ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

// Type declarations for Web Speech API
declare global {
  interface Window {
    SpeechSynthesis: typeof SpeechSynthesis;
    SpeechRecognition: typeof SpeechRecognition;
    webkitSpeechRecognition: typeof SpeechRecognition;
    speechSynthesis: SpeechSynthesis;
  }
}

export interface AccessibilityConfig {
  speechRate: number;
  voiceURI: string;
  volume: number;
  pitch: number;
  hapticFeedback: boolean;
  autoCorrect: boolean;
  errorTolerance: number;
  commandDelay: number;
}

export interface VoiceCommand {
  command: string;
  action: () => void;
  description: string;
  examples: string[];
}

export interface FeedbackOptions {
  visual?: boolean;
  audio?: boolean;
  haptic?: boolean;
  priority?: boolean;
}

export class AccessibilityCore {
  private synthesis: SpeechSynthesis;
  private recognition: SpeechRecognition;
  private commands: Map<string, VoiceCommand>;
  private lastCommand: string = '';
  private lastCommandTime: number = 0;
  private errorCount: number = 0;
  private isListening: boolean = false;

  constructor(private config: AccessibilityConfig) {
    // Initialize speech synthesis and recognition
    console.info('Initializing AccessibilityCore with config:', config);
    this.synthesis = window.speechSynthesis;
    this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    this.commands = new Map();

    // Initialize with default configuration
    this.config = {
      speechRate: 1,
      voiceURI: '',
      volume: 1,
      pitch: 1,
      hapticFeedback: true,
      autoCorrect: true,
      errorTolerance: 3,
      commandDelay: 1000,
      ...config
    };

    this.initializeVoiceCommands();
    this.setupErrorHandling();
  }

  private initializeVoiceCommands() {
    console.info('Setting up voice recognition system...');

    this.recognition.continuous = true;
    this.recognition.interimResults = true;
    this.recognition.maxAlternatives = 3;

    // Register default commands
    this.registerCommand({
      command: 'start lesson',
      action: () => this.provideFeedback('Starting new lesson...', { audio: true, visual: true }),
      description: 'Starts a new typing lesson',
      examples: ['start lesson', 'begin lesson', 'new lesson']
    });

    this.registerCommand({
      command: 'pause',
      action: () => this.provideFeedback('Lesson paused. Say "resume" to continue.', { audio: true }),
      description: 'Pauses the current lesson',
      examples: ['pause', 'stop', 'wait']
    });

    this.registerCommand({
      command: 'resume',
      action: () => this.provideFeedback('Resuming lesson...', { audio: true }),
      description: 'Resumes the paused lesson',
      examples: ['resume', 'continue', 'go on']
    });

    this.registerCommand({
      command: 'repeat',
      action: () => this.provideFeedback('Repeating last instruction...', { audio: true }),
      description: 'Repeats the last instruction',
      examples: ['repeat', 'say again', 'what was that']
    });

    // Set up recognition handlers
    this.recognition.onstart = () => {
      console.info('Voice recognition started');
      this.isListening = true;
      this.provideFeedback('Voice control activated', { visual: true });
    };

    this.recognition.onend = () => {
      console.info('Voice recognition ended');
      this.isListening = false;
      if (this.errorCount < this.config.errorTolerance) {
        this.recognition.start();
      }
    };

    this.recognition.onerror = (event) => {
      console.error('Voice recognition error:', event.error);
      this.handleError(event);
    };

    this.recognition.onresult = (event) => {
      const result = event.results[event.results.length - 1];
      const transcript = result[0].transcript.toLowerCase().trim();

      console.info('Voice command received:', transcript);
      this.processCommand(transcript, result[0].confidence);
    };
  }

  private processCommand(transcript: string, confidence: number) {
    // Prevent command spam
    const now = Date.now();
    if (now - this.lastCommandTime < this.config.commandDelay) {
      return;
    }

    // Find best matching command
    let bestMatch: VoiceCommand | undefined;
    let bestConfidence = 0;

    this.commands.forEach((command, key) => {
      const similarity = this.calculateSimilarity(transcript, key);
      if (similarity > bestConfidence) {
        bestConfidence = similarity;
        bestMatch = command;
      }
    });

    if (bestMatch && bestConfidence > 0.8) {
      console.info('Executing command:', bestMatch.description);
      bestMatch.action();
      this.lastCommand = transcript;
      this.lastCommandTime = now;
      this.errorCount = 0;
    } else {
      this.provideFeedback('Command not recognized. Please try again.', { audio: true });
      this.errorCount++;
    }
  }

  private calculateSimilarity(str1: string, str2: string): number {
    // Implement Levenshtein distance or similar algorithm
    // This is a simplified version
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();
    return s1.includes(s2) || s2.includes(s1) ? 1 : 0;
  }

  private setupErrorHandling() {
    window.addEventListener('error', (event) => {
      console.error('Global error caught:', event.error);
      this.handleError(event);
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      this.handleError(event);
    });
  }

  private handleError(error: any) {
    this.errorCount++;
    console.error('Error in AccessibilityCore:', error);

    if (this.errorCount >= this.config.errorTolerance) {
      this.provideFeedback(
        'Voice control is having trouble. Switching to keyboard mode.',
        { audio: true, visual: true, priority: true }
      );
      this.recognition.stop();
    }
  }

  public registerCommand(command: VoiceCommand) {
    this.commands.set(command.command, command);
    console.info('Registered new command:', command.description);
  }

  public provideFeedback(message: string, options: FeedbackOptions = {}) {
    console.info('Providing feedback:', { message, options });

    // Visual feedback
    if (options.visual) {
      // Dispatch custom event for UI updates
      window.dispatchEvent(new CustomEvent('accessibility-feedback', {
        detail: { message, type: 'visual' }
      }));
    }

    // Audio feedback
    if (options.audio !== false) {
      const utterance = new SpeechSynthesisUtterance(message);
      utterance.rate = this.config.speechRate;
      utterance.volume = this.config.volume;
      utterance.pitch = this.config.pitch;

      if (options.priority) {
        this.synthesis.cancel();
      }

      this.synthesis.speak(utterance);
    }

    // Haptic feedback
    if (options.haptic && this.config.hapticFeedback && navigator.vibrate) {
      navigator.vibrate(200);
    }
  }

  public startListening() {
    if (!this.isListening) {
      try {
        this.recognition.start();
        console.info('Voice recognition started');
      } catch (error) {
        console.error('Error starting voice recognition:', error);
        this.handleError(error);
      }
    }
  }

  public stopListening() {
    if (this.isListening) {
      try {
        this.recognition.stop();
        console.info('Voice recognition stopped');
      } catch (error) {
        console.error('Error stopping voice recognition:', error);
        this.handleError(error);
      }
    }
  }

  public updateConfig(newConfig: Partial<AccessibilityConfig>) {
    this.config = { ...this.config, ...newConfig };
    console.info('Updated accessibility configuration:', this.config);
  }
}```


🟦 File: src/components/ui/use-toast.ts
───────────────────────────────────────────────────
```ts
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Toast Hook                                                                             ║
 * ║ Description: React hook for managing toast notifications                                       ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_VALUE
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
```


🟦 File: src/components/ui/tooltip.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Tooltip                                                                             ║
 * ║ Description: Tooltip component with smooth animations and positioning                          ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```


🟦 File: src/components/ui/toggle.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
```


🟦 File: src/components/ui/toggle-group.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
```


🟦 File: src/components/ui/toaster.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Toast Provider                                                                         ║
 * ║ Description: Toast notification provider component with animations                             ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"
import { useToast } from "@/components/ui/use-toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
```


🟦 File: src/components/ui/toast.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Module: Toast Component                                                                        ║
 * ║ Description: Toast notification component with variants and animations                         ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
```


🟦 File: src/components/ui/textarea.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
```


🟦 File: src/components/ui/tabs.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Tabs                                                                                ║
 * ║ Description: Tabs component with smooth transitions and keyboard navigation                    ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
```


🟦 File: src/components/ui/table.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Table                                                                               ║
 * ║ Description: Accessible table component with consistent styling                                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
```


🟦 File: src/components/ui/switch.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
```


🟦 File: src/components/ui/spinner.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Spinner                                                                             ║
 * ║ Description: Loading spinner component with size variants and smooth animations                ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const spinnerVariants = cva(
  'inline-block animate-spin rounded-full border-solid border-current border-r-transparent motion-reduce:animate-[spin_1.5s_linear_infinite]',
  {
    variants: {
      size: {
        default: 'h-4 w-4 border-2',
        sm: 'h-3 w-3 border-2',
        lg: 'h-6 w-6 border-3',
        xl: 'h-8 w-8 border-4',
      },
      variant: {
        default: 'text-primary',
        secondary: 'text-secondary',
        destructive: 'text-destructive',
        muted: 'text-muted-foreground',
      },
    },
    defaultVariants: {
      size: 'default',
      variant: 'default',
    },
  }
);

export interface SpinnerProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof spinnerVariants> {
  label?: string;
}

const Spinner = React.forwardRef<HTMLDivElement, SpinnerProps>(
  ({ className, size, variant, label = 'Loading...', ...props }, ref) => {
    return (
      <div
        ref={ref}
        role="status"
        aria-label={label}
        className={cn('relative', className)}
        {...props}
      >
        <div className={cn(spinnerVariants({ size, variant }))} />
        <span className="sr-only">{label}</span>
      </div>
    );
  }
);

Spinner.displayName = 'Spinner';

export { Spinner, spinnerVariants };```


🟦 File: src/components/ui/sonner.tsx
───────────────────────────────────────────────────
```tsx
import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
```


🟦 File: src/components/ui/slider.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
```


🟦 File: src/components/ui/skeleton.tsx
───────────────────────────────────────────────────
```tsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
```


🟦 File: src/components/ui/sheet.tsx
───────────────────────────────────────────────────
```tsx
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
  VariantProps<typeof sheetVariants> { }

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet, SheetClose,
  SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetOverlay, SheetPortal, SheetTitle, SheetTrigger
}

```


🟦 File: src/components/ui/separator.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
```


🟦 File: src/components/ui/select.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Select                                                                              ║
 * ║ Description: Select component with smooth animations and keyboard navigation                   ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
```


🟦 File: src/components/ui/scroll-area.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
```


🟦 File: src/components/ui/resizable.tsx
───────────────────────────────────────────────────
```tsx
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
```


🟦 File: src/components/ui/radio-group.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
```


🟦 File: src/components/ui/progress.tsx
───────────────────────────────────────────────────
```tsx
/*
 * ████████╗██╗   ██╗████████╗ ██████╗ ██████╗     ██████╗ ██████╗  █████╗ ██╗███╗   ██╗
 * ╚══██╔══╝██║   ██║╚══██╔══╝██╔═══██╗██╔══██╗    ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██████╔╝    ██████╔╝██████╔╝███████║██║██╔██╗ ██║
 *    ██║   ██║   ██║   ██║   ██║   ██║██╔══██╗    ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║
 *    ██║   ╚██████╔╝   ██║   ╚██████╔╝██║  ██║    ██████╔╝██║  ██║██║  ██║██║██║ ╚████║
 *    ╚═╝    ╚═════╝    ╚═╝    ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║ Component: Progress                                                                            ║
 * ║ Description: Progress bar component with smooth animations                                     ║
 * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝
 */

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
```


🟦 File: src/components/ui/popover.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
```


🟦 File: src/components/ui/pagination.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
```


🟦 File: src/components/ui/navigation-menu.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
```


🟦 File: src/components/ui/menubar.tsx
───────────────────────────────────────────────────
```tsx
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
```

📊 Dump Statistics
───────────────────────────────────────────────────
Total words: 3818
Estimated tokens: 4963.4
Generated on: Tue Feb 18 08:23:49 PST 2025
